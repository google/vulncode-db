# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from data.models.vulnerability import Vulnerability
import io
import pytest
from urllib.error import HTTPError, URLError
from tests.conftest import as_admin, as_user

VULN_VIEW_VARIANTS = [
    ("CVE-1970-1000", 200, b"CVE-1970-1000"),  # no redirect
    ("1", 302, b"/CVE-1970-1000"),  # redirect expected
    ("CVE-1970-1500", 200, b"CVE-1970-1500"),  # no commit
    ("CVE-1970-9000", 404, b"not found"),  # cve not found
    ("9999", 404, b"not found"),  # id not found
    ("Invalid ID", 404, b"not found"),  # invalid id
]
VULN_VIEW_DETAILS_VARIANTS = VULN_VIEW_VARIANTS[:]
VULN_VIEW_DETAILS_VARIANTS[-1] = (
    "Invalid ID",
    302,
    b'target URL: <a href="/">',
)  # redirect on invalid ID
VULN_VIEW_ANNOT_VARIANTS = VULN_VIEW_VARIANTS[:]
VULN_VIEW_ANNOT_VARIANTS[0] = ("CVE-1970-1000", 200, b"[]")
VULN_VIEW_ANNOT_VARIANTS[2] = ("CVE-1970-1500", 404, b"no linked Git link")
VULN_EMBED_VARIANTS = [
    ("CVE-1970-1000", 200, b"CVE-1970-1000"),  # no redirect
    ("1", 302, b"/CVE-1970-1000"),  # redirect expected
    ("CVE-1970-1500", 404, b"has no linked Git commits"),  # no commit
    ("CVE-1970-9000", 404, b"No vulnerability found"),  # cve not found
    ("9999", 404, b"No vulnerability found"),  # id not found
    ("Invalid ID", 404, b"No vulnerability found"),  # invalid id
]
CREATE_NEW_VULN_VARIANTS = [
    (
        {
            "cve_id": "CVE-1970-3000",
            "comment": "This is a new bug!!11",
            "commits-0-commit_link": "https://github.com/OWNER/REPO/commit/12345678",
            "commits-0-repo_name": "REPO",
            "commits-0-repo_url": "https://github.com/OWNER/REPO",
            "commits-0-commit_hash": "12345678",
        }
    ),
    (
        {
            "cve_id": "CVE-1970-3000",
            "comment": "This is a new bug!!11",
            "commits-0-commit_link": "https://github.com/OWNER/REPO/commit/12345678",
            "commits-0-repo_name": "REPO",
            "commits-0-repo_url": "",
            "commits-0-commit_hash": "12345678",
        }
    ),
    (
        {
            "cve_id": "CVE-1970-3000",
            "comment": "This is a new bug!!11",
            "commits-0-commit_link": "https://github.com/OWNER/REPO/commit/12345678",
            "commits-0-repo_name": "REPO",
            "commits-0-repo_url": "https://github.com/OWNER/REPO",
            "commits-0-commit_hash": "",
        }
    ),
    (
        {
            "cve_id": None,
            "comment": "This is a new bug!!11",
            "commits-0-commit_link": "https://github.com/OWNER/REPO/commit/12345678",
            "commits-0-repo_name": "REPO",
            "commits-0-repo_url": "https://github.com/OWNER/REPO",
            "commits-0-commit_hash": "12345678",
        }
    ),
]
CREATE_NEW_VULN_FAIL_VARIANTS = [
    (
        {
            "cve_id": "CVE-1970-3000",
            "comment": "",
            "commits-0-commit_link": "https://github.com/OWNER/REPO/commit/12345678",
            "commits-0-repo_name": "REPO",
            "commits-0-repo_url": "https://github.com/OWNER/REPO",
            "commits-0-commit_hash": "12345678",
        },
        b"This field is required.",
    ),
    # TODO: reenable when CVE-ID modification is reconsidered
    # ({
    #     'cve_id': 'Invalid ID',
    #     'comment': 'This is a new bug!!11',
    #     'commits-0-commit_link':
    #     'https://github.com/OWNER/REPO/commit/12345678',
    #     'commits-0-repo_name': 'REPO',
    #     'commits-0-repo_url': 'https://github.com/OWNER/REPO',
    #     'commits-0-commit_hash': '12345678',
    # }, b'Invalid input.'),
]
VULN_TREE_VARIANTS = [
    (
        "CVE-1970-1000",
        200,
        b'"message": "Fixes all evil"',
        None,
        io.BytesIO(
            b"""{
        "commit": {
            "parent_hash": "12345678",
            "date": 0,
            "message": "Fixes all evil",
            "stats": {
                "additions": 1,
                "deletions": 1,
                "total": 2
            },
            "files": [
                {
                    "path": "src/main.c",
                    "status": "modified",
                    "additions": 1,
                    "deletions": 1
                }
            ]
        }
    }"""
        ),
    ),  # valid response
    ("CVE-1970-1000", 200, b"", None, io.BytesIO(b"")),  # empty response
    (
        "CVE-1970-1000",
        404,
        b"vcs not found",
        HTTPError("/", 404, "vcs not found", {}, io.StringIO("vcs not found")),
        None,
    ),  # not found
    (
        "CVE-1970-1000",
        400,
        b"something wrong",
        URLError("something wrong"),
        None,
    ),  # url error
    ("CVE-1970-1500", 404, b"not found", None, "None"),  # no commit
    ("CVE-1970-9000", 404, b"not found", None, None),  # cve not found
    ("9999", 404, b"not found", None, None),  # id not found
    ("Invalid ID", 404, b"not found", None, None),  # invalid id
]


@pytest.mark.integration
@pytest.mark.parametrize(
    "input_id,expected_status,expected_content", VULN_VIEW_VARIANTS
)
def test_view_vulnerability(client, input_id, expected_status, expected_content):
    resp = client.get("/" + input_id)
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize(
    "input_id,expected_status,expected_content", VULN_VIEW_DETAILS_VARIANTS
)
def test_view_vulnerability_details(
    client, input_id, expected_status, expected_content
):
    resp = client.get("/{}/details".format(input_id))
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize(
    "input_id,expected_status,expected_content", VULN_VIEW_ANNOT_VARIANTS
)
def test_get_vulnerability_annotation_data(
    client, input_id, expected_status, expected_content
):
    resp = client.get("/{}/annotation_data".format(input_id))
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize("data", CREATE_NEW_VULN_VARIANTS)
@pytest.mark.parametrize(
    "use_group, expected_status",
    [
        (None, 403),
        (as_user, 403),
        (as_admin, 302),
    ],
)
def test_create_new_vulnerability(
    client, db, db_session, data, use_group, expected_status
):
    if use_group:
        use_group(client)

    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db.engine.execute(
        "SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'"
    ).scalar()

    resp = client.post("/create", data=data)
    assert resp.status_code == expected_status

    if use_group == as_admin:
        assert resp.headers.get("Location", "<empty>").endswith(f"/{next_id}")

    vuln = db_session.query(Vulnerability).get(next_id)
    if use_group == as_admin:
        expected = CREATE_NEW_VULN_VARIANTS[0]
        assert vuln.comment == data["comment"]
        # TODO: CVE-ID edit currently not allowed
        assert vuln.cve_id == data["cve_id"] or vuln.cve_id is None
        assert len(vuln.commits) == 1
        assert vuln.commits[0].commit_link == expected["commits-0-commit_link"]
        assert vuln.commits[0].repo_name == expected["commits-0-repo_name"]
        assert vuln.commits[0].repo_url == expected["commits-0-repo_url"]
        assert vuln.commits[0].commit_hash == expected["commits-0-commit_hash"]
    else:
        assert vuln is None


@pytest.mark.integration
@pytest.mark.parametrize("data, expected_response", CREATE_NEW_VULN_FAIL_VARIANTS)
@pytest.mark.parametrize(
    "use_group, expected_status",
    [
        (None, 403),
        (as_user, 403),
        (as_admin, 200),
    ],
)
def test_create_new_vulnerability_failure(
    client, db, data, expected_response, use_group, expected_status
):
    if use_group:
        use_group(client)
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db.engine.execute(
        "SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'"
    ).scalar()

    resp = client.post("/create", data=data)
    assert resp.status_code == expected_status

    if use_group == as_admin:
        assert expected_response in resp.data
    else:
        assert b"Forbidden" in resp.data


@pytest.mark.integration
@pytest.mark.parametrize(
    "use_group, expected_status, expected_response",
    [
        (None, 403, b"Forbidden"),
        (as_user, 403, b"Forbidden"),
        (as_admin, 200, b"Add a new vulnerability"),
    ],
)
def test_get_new_vuln_page(client, use_group, expected_status, expected_response):
    if use_group:
        use_group(client)
    resp = client.get("/create")
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize(
    "use_group, expected_status, expected_response",
    [
        (None, 403, b"Forbidden"),
        (as_user, 403, b"Forbidden"),
        (as_admin, 200, b"Add a new vulnerability"),
    ],
)
def test_get_update_vuln_page(client, use_group, expected_status, expected_response):
    if use_group:
        use_group(client)
    resp = client.get("/CVE-1970-1000/create")
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize(
    "use_group, expected_status, expected_response",
    [
        (None, 403, b"Forbidden"),
        (as_user, 403, b"Forbidden"),
        (as_admin, 200, b"Add a new vulnerability"),
    ],
)
def test_create_vuln_page_if_nonexisting(
    client, use_group, expected_status, expected_response
):
    if use_group:
        use_group(client)
    resp = client.get("/CVE-1970-9000/create")
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize(
    "use_group, expected_status, expected_response",
    [
        (None, 403, b"Forbidden"),
        (as_user, 403, b"Forbidden"),
        (as_admin, 200, b"Add a new vulnerability"),
    ],
)
def test_create_vuln_page_if_invali(
    client, use_group, expected_status, expected_response
):
    if use_group:
        use_group(client)
    resp = client.get("/INVALID_ID/create")
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize(
    "use_group, expected_status, expected_deletion",
    [
        (None, 403, False),
        (as_user, 403, False),
        (as_admin, 302, True),
    ],
)
def test_delete_vulnerability_entry(
    client, use_group, expected_status, expected_deletion
):
    if use_group:
        use_group(client)
    vuln = Vulnerability.get_by_cve_id("CVE-1970-1000")
    assert vuln is not None

    resp = client.post(
        "/CVE-1970-1000/create",
        data={
            "delete_entry": vuln.id,
        },
    )
    assert resp.status_code == expected_status

    vuln = Vulnerability.get_by_cve_id("CVE-1970-1000")
    if expected_deletion:
        assert vuln is None
    else:
        assert vuln is not None


@pytest.mark.integration
@pytest.mark.parametrize(
    "use_group, expected_status",
    [
        (None, 403),
        (as_user, 403),
        (as_admin, 302),
    ],
)
def test_update_vulnerability(client, db_session, use_group, expected_status):
    if use_group:
        use_group(client)
    data = {
        "cve_id": "CVE-1970-1000",
        "comment": "This is the new comment",
        "commits-0-commit_link": "https://github.com/OWNER/REPO/commit/12345678",
        "commits-0-repo_name": "REPO",
        "commits-0-repo_url": "https://github.com/OWNER/REPO",
        "commits-0-commit_hash": "12345678",
    }

    resp = client.post("/CVE-1970-1000/create", data=data)
    assert resp.status_code == expected_status
    if use_group == as_admin:
        assert resp.headers.get("Location", "<empty>").endswith(f"/1")

    vuln = Vulnerability.get_by_id(1)
    assert vuln.cve_id == data["cve_id"]
    assert len(vuln.commits) == 1

    if use_group == as_admin:
        assert vuln.comment == data["comment"]
        assert vuln.commits[0].commit_link == data["commits-0-commit_link"]
        assert vuln.commits[0].repo_name == data["commits-0-repo_name"]
        assert vuln.commits[0].repo_url == data["commits-0-repo_url"]
        assert vuln.commits[0].commit_hash == data["commits-0-commit_hash"]
    else:
        assert vuln.comment == "Vulnerability 1 comment"
        assert (
            vuln.commits[0].commit_link
            == "https://github.com/OWNER/REPO1/commit/1234568"
        )
        assert vuln.commits[0].repo_name == "REPO1"
        assert vuln.commits[0].repo_url == "https://github.com/OWNER/REPO1"
        assert vuln.commits[0].commit_hash == "1234568"


@pytest.mark.integration
@pytest.mark.parametrize(
    "use_group, expected_status",
    [
        (None, 403),
        (as_user, 302),
        (as_admin, 302),
    ],
)
def test_add_proposal(client, use_group, expected_status):
    # TODO: Add proper testing for this...
    if use_group:
        use_group(client)
    data = {
        "cve_id": "CVE-1970-1000",
        "comment": "This is a new proposal",
        "commits-0-commit_link": "https://github.com/OWNER/REPO/commit/12345678",
        "commits-0-repo_name": "REPO",
        "commits-0-repo_url": "https://github.com/OWNER/REPO",
        "commits-0-commit_hash": "12345678",
    }
    resp = client.post("/CVE-1970-1000/edit", data=data)
    assert resp.status_code == expected_status


@pytest.mark.integration
@pytest.mark.parametrize(
    "input_id,expected_status,expected_content", VULN_EMBED_VARIANTS
)
def test_embed_vulnerability(client, input_id, expected_status, expected_content):
    resp = client.get(f"/{input_id}/embed")
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
def test_editor(client):
    as_admin(client)
    resp = client.get("/CVE-1970-1000/editor")
    assert resp.status_code == 200


@pytest.mark.integration
@pytest.mark.parametrize(
    "input_id,expected_status,expected_content,side_effect,return_value",
    VULN_TREE_VARIANTS,
)
def test_tree_vulnerability(
    client,
    mocker,
    input_id,
    expected_status,
    expected_content,
    side_effect,
    return_value,
):
    mocked_urlopen = mocker.patch("urllib.request.urlopen")
    mocked_urlopen.side_effect = side_effect
    mocked_urlopen.return_value = return_value

    resp = client.get(f"/{input_id}/tree")
    assert resp.status_code == expected_status
    assert expected_content in resp.data
