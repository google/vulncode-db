# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from data.models.vulnerability import Vulnerability
import io
import pytest
from urllib.error import HTTPError, URLError
from tests.conftest import as_admin, as_user

VULN_VIEW_VARIANTS = [
    ('CVE-1970-1000', 200, b'CVE-1970-1000'),  # no redirect
    ('1', 302, b'/CVE-1970-1000'),  # redirect expected
    ('CVE-1970-1500', 200, b'CVE-1970-1500'),  # no commit
    ('CVE-1970-9000', 404, b'not found'),  # cve not found
    ('9999', 404, b'not found'),  # id not found
    ('Invalid ID', 404, b'not found'),  # invalid id
]
VULN_VIEW_DETAILS_VARIANTS = VULN_VIEW_VARIANTS[:]
VULN_VIEW_DETAILS_VARIANTS[-1] = ('Invalid ID', 302,
                                  b'target URL: <a href="/">'
                                  )  # redirect on invalid ID
VULN_VIEW_ANNOT_VARIANTS = VULN_VIEW_VARIANTS[:]
VULN_VIEW_ANNOT_VARIANTS[0] = ('CVE-1970-1000', 200, b'[]')
VULN_VIEW_ANNOT_VARIANTS[2] = ('CVE-1970-1500', 404, b'no linked Git link')
VULN_EMBED_VARIANTS = [
    ('CVE-1970-1000', 200, b'CVE-1970-1000'),  # no redirect
    ('1', 302, b'/CVE-1970-1000'),  # redirect expected
    ('CVE-1970-1500', 404, b'has no linked Git commits'),  # no commit
    ('CVE-1970-9000', 404, b'No vulnerability found'),  # cve not found
    ('9999', 404, b'No vulnerability found'),  # id not found
    ('Invalid ID', 404, b'No vulnerability found'),  # invalid id
]
CREATE_NEW_VULN_VARIANTS = [
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link':
        'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }),
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link':
        'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': '',
        'commits-0-commit_hash': '12345678',
    }),
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link':
        'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '',
    }),
    ({
        'cve_id': None,
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link':
        'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }),
]
CREATE_NEW_VULN_FAIL_VARIANTS = [
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': '',
        'commits-0-commit_link':
        'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }, b'This field is required.'),
    # TODO: reenable when CVE-ID modification is reconsidered
    # ({
    #     'cve_id': 'Invalid ID',
    #     'comment': 'This is a new bug!!11',
    #     'commits-0-commit_link':
    #     'https://github.com/OWNER/REPO/commit/12345678',
    #     'commits-0-repo_name': 'REPO',
    #     'commits-0-repo_url': 'https://github.com/OWNER/REPO',
    #     'commits-0-commit_hash': '12345678',
    # }, b'Invalid input.'),
]
VULN_TREE_VARIANTS = [
    ('CVE-1970-1000', 200, b'"message": "Fixes all evil"', None,
     io.BytesIO(b'''{
        "commit": {
            "parent_hash": "12345678",
            "date": 0,
            "message": "Fixes all evil",
            "stats": {
                "additions": 1,
                "deletions": 1,
                "total": 2
            },
            "files": [
                {
                    "path": "src/main.c",
                    "status": "modified",
                    "additions": 1,
                    "deletions": 1
                }
            ]
        }
    }''')),  # valid response
    ('CVE-1970-1000', 200, b'', None, io.BytesIO(b'')),  # empty response
    ('CVE-1970-1000', 404, b'vcs not found',
     HTTPError('/', 404, 'vcs not found', {},
               io.StringIO('vcs not found')), None),  # not found
    ('CVE-1970-1000', 400, b'something wrong', URLError('something wrong'),
     None),  # url error
    ('CVE-1970-1500', 404, b'not found', None, 'None'),  # no commit
    ('CVE-1970-9000', 404, b'not found', None, None),  # cve not found
    ('9999', 404, b'not found', None, None),  # id not found
    ('Invalid ID', 404, b'not found', None, None),  # invalid id
]


@pytest.mark.integration
@pytest.mark.parametrize('input_id,expected_status,expected_content',
                         VULN_VIEW_VARIANTS)
def test_view_vulnerability(client, input_id, expected_status,
                            expected_content):
    resp = client.get('/' + input_id)
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('input_id,expected_status,expected_content',
                         VULN_VIEW_DETAILS_VARIANTS)
def test_view_vulnerability_details(client, input_id, expected_status,
                                    expected_content):
    resp = client.get('/{}/details'.format(input_id))
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('input_id,expected_status,expected_content',
                         VULN_VIEW_ANNOT_VARIANTS)
def test_get_vulnerability_annotation_data(client, input_id, expected_status,
                                           expected_content):
    resp = client.get('/{}/annotation_data'.format(input_id))
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('data', CREATE_NEW_VULN_VARIANTS)
@pytest.mark.parametrize('use_group, expected_status', [
    (None, 403),
    (as_user, 403),
    (as_admin, 302),
])
def test_create_new_vulnerability(client, db_engine, db_session, data,
                                  use_group, expected_status):
    if use_group:
        use_group(client)

    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute(
        "SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'"
    ).scalar()

    resp = client.post('/create', data=data)
    assert resp.status_code == expected_status

    if use_group == as_admin:
        assert resp.headers.get('Location', '<empty>').endswith(f'/{next_id}')

    vuln = db_session.query(Vulnerability).get(next_id)
    if use_group == as_admin:
        expected = CREATE_NEW_VULN_VARIANTS[0]
        assert vuln.comment == data['comment']
        # TODO: CVE-ID edit currently not allowed
        assert vuln.cve_id == data['cve_id'] or vuln.cve_id is None
        assert len(vuln.commits) == 1
        assert vuln.commits[0].commit_link == expected['commits-0-commit_link']
        assert vuln.commits[0].repo_name == expected['commits-0-repo_name']
        assert vuln.commits[0].repo_url == expected['commits-0-repo_url']
        assert vuln.commits[0].commit_hash == expected['commits-0-commit_hash']
    else:
        assert vuln is None


@pytest.mark.integration
@pytest.mark.parametrize('data, expected_response',
                         CREATE_NEW_VULN_FAIL_VARIANTS)
@pytest.mark.parametrize('use_group, expected_status', [
    (None, 403),
    (as_user, 403),
    (as_admin, 200),
])
def test_create_new_vulnerability_failure(client, db_engine, data,
                                          expected_response, use_group,
                                          expected_status):
    if use_group:
        use_group(client)
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute(
        "SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'"
    ).scalar()

    resp = client.post('/create', data=data)
    assert resp.status_code == expected_status

    if use_group == as_admin:
        assert expected_response in resp.data
    else:
        assert b'Forbidden' in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('use_group, expected_status, expected_response', [
    (None, 403, b'Forbidden'),
    (as_user, 403, b'Forbidden'),
    (as_admin, 200, b'Add a new vulnerability'),
])
def test_get_new_vuln_page(client, use_group, expected_status,
                           expected_response):
    if use_group:
        use_group(client)
    resp = client.get('/create')
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('use_group, expected_status, expected_response', [
    (None, 403, b'Forbidden'),
    (as_user, 403, b'Forbidden'),
    (as_admin, 200, b'Add a new vulnerability'),
])
def test_get_update_vuln_page(client, use_group, expected_status,
                              expected_response):
    if use_group:
        use_group(client)
    resp = client.get('/CVE-1970-1000/create')
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('use_group, expected_status, expected_response', [
    (None, 403, b'Forbidden'),
    (as_user, 403, b'Forbidden'),
    (as_admin, 200, b'Add a new vulnerability'),
])
def test_create_vuln_page_if_nonexisting(client, use_group, expected_status,
                                         expected_response):
    if use_group:
        use_group(client)
    resp = client.get('/CVE-1970-9000/create')
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('use_group, expected_status, expected_response', [
    (None, 403, b'Forbidden'),
    (as_user, 403, b'Forbidden'),
    (as_admin, 200, b'Add a new vulnerability'),
])
def test_create_vuln_page_if_invali(client, use_group, expected_status,
                                    expected_response):
    if use_group:
        use_group(client)
    resp = client.get('/INVALID_ID/create')
    assert resp.status_code == expected_status
    assert expected_response in resp.data


@pytest.mark.integration
@pytest.mark.parametrize('use_group, expected_status, expected_deletion', [
    (None, 403, False),
    (as_user, 403, False),
    (as_admin, 302, True),
])
def test_delete_vulnerability_entry(client, use_group, expected_status,
                                    expected_deletion):
    if use_group:
        use_group(client)
    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    assert vuln is not None

    resp = client.post('/CVE-1970-1000/create',
                       data={
                           'delete_entry': vuln.id,
                       })
    assert resp.status_code == expected_status

    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    if expected_deletion:
        assert vuln is None
    else:
        assert vuln is not None


@pytest.mark.integration
@pytest.mark.parametrize('use_group, expected_status', [
    (None, 403),
    (as_user, 403),
    (as_admin, 302),
])
def test_update_vulnerability(client, db_session, use_group, expected_status):
    if use_group:
        use_group(client)
    data = {
        'cve_id': 'CVE-1970-1000',
        'comment': 'This is the new comment',
        'commits-0-commit_link':
        'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }

    resp = client.post('/CVE-1970-1000/create', data=data)
    assert resp.status_code == expected_status
    if use_group == as_admin:
        assert resp.headers.get('Location', '<empty>').endswith(f'/1')

    vuln = Vulnerability.get_by_id(1)
    assert vuln.cve_id == data['cve_id']
    assert len(vuln.commits) == 1

    if use_group == as_admin:
        assert vuln.comment == data['comment']
        assert vuln.commits[0].commit_link == data['commits-0-commit_link']
        assert vuln.commits[0].repo_name == data['commits-0-repo_name']
        assert vuln.commits[0].repo_url == data['commits-0-repo_url']
        assert vuln.commits[0].commit_hash == data['commits-0-commit_hash']
    else:
        assert vuln.comment == 'Vulnerability 1 comment'
        assert vuln.commits[
            0].commit_link == 'https://github.com/OWNER/REPO1/commit/1234568'
        assert vuln.commits[0].repo_name == 'REPO1'
        assert vuln.commits[0].repo_url == 'https://github.com/OWNER/REPO1'
        assert vuln.commits[0].commit_hash == '1234568'


@pytest.mark.integration
@pytest.mark.parametrize('use_group, expected_status', [
    (None, 403),
    (as_user, 302),
    (as_admin, 302),
])
def test_add_proposal(client, use_group, expected_status):
    # TODO: Add proper testing for this...
    if use_group:
        use_group(client)
    data = {
        'cve_id': 'CVE-1970-1000',
        'comment': 'This is a new proposal',
        'commits-0-commit_link':
        'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }
    resp = client.post('/CVE-1970-1000/edit', data=data)
    assert resp.status_code == expected_status


@pytest.mark.integration
@pytest.mark.parametrize('input_id,expected_status,expected_content',
                         VULN_EMBED_VARIANTS)
def test_embed_vulnerability(client, input_id, expected_status,
                             expected_content):
    resp = client.get(f'/{input_id}/embed')
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
def test_editor(client):
    as_admin(client)
    resp = client.get('/CVE-1970-1000/editor')
    assert resp.status_code == 200


@pytest.mark.integration
@pytest.mark.parametrize(
    'input_id,expected_status,expected_content,side_effect,return_value',
    VULN_TREE_VARIANTS)
def test_tree_vulnerability(client, mocker, input_id, expected_status,
                            expected_content, side_effect, return_value):
    mocked_urlopen = mocker.patch('urllib.request.urlopen')
    mocked_urlopen.side_effect = side_effect
    mocked_urlopen.return_value = return_value

    resp = client.get(f'/{input_id}/tree')
    assert resp.status_code == expected_status
    assert expected_content in resp.data
