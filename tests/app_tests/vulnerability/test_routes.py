# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from data.models.vulnerability import Vulnerability
import io
import pytest
from urllib.error import HTTPError, URLError
from tests.conftest import as_admin, as_user


VULN_VIEW_VARIANTS = [
    ('CVE-1970-1000', 200, b'CVE-1970-1000'),  # no redirect
    ('1', 308, b'/CVE-1970-1000'),  # redirect expected
    ('CVE-1970-1500', 200, b'CVE-1970-1500'),  # no commit
    ('CVE-1970-9000', 404, b'not found'),  # cve not found
    ('9999', 404, b'not found'),  # id not found
    ('Invalid ID', 404, b'not found'),  # invalid id
]
VULN_VIEW_DETAILS_VARIANTS = VULN_VIEW_VARIANTS[:]
VULN_VIEW_DETAILS_VARIANTS[-1] = ('Invalid ID', 302, b'target URL: <a href="/">')  # redirect on invalid ID
VULN_VIEW_ANNOT_VARIANTS = VULN_VIEW_VARIANTS[:]
VULN_VIEW_ANNOT_VARIANTS[0] = ('CVE-1970-1000', 200, b'[]')
VULN_VIEW_ANNOT_VARIANTS[2] = ('CVE-1970-1500', 404, b'no linked Git link')
VULN_EMBED_VARIANTS = [
    ('CVE-1970-1000', 200, b'CVE-1970-1000'),  # no redirect
    ('1', 308, b'/CVE-1970-1000'),  # redirect expected
    ('CVE-1970-1500', 404, b'has no linked Git commits'),  # no commit
    ('CVE-1970-9000', 404, b'No vulnerability found'),  # cve not found
    ('9999', 404, b'No vulnerability found'),  # id not found
    ('Invalid ID', 404, b'No vulnerability found'),  # invalid id
]
CREATE_NEW_VULN_VARIANTS = [
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }, 302),
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': '',
        'commits-0-commit_hash': '12345678',
    }, 302),
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '',
    }, 302),
    ({
        'cve_id': None,
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }, 302),
]
CREATE_NEW_VULN_FAIL_VARIANTS = [
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': '',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }, 200, b'This field is required.'),
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link': '',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }, 200, b'This field is required.'),
    ({
        'cve_id': 'CVE-1970-3000',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': '',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }, 200, b'This field is required.'),
    ({
        'cve_id': 'Invalid ID',
        'comment': 'This is a new bug!!11',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }, 200, b'Invalid input.'),
]
VULN_TREE_VARIANTS = [
    ('CVE-1970-1000', 200, b'"message": "Fixes all evil"', None, io.BytesIO(b'''{
        "commit": {
            "parent_hash": "12345678",
            "date": 0,
            "message": "Fixes all evil",
            "stats": {
                "additions": 1,
                "deletions": 1,
                "total": 2
            },
            "files": [
                {
                    "path": "src/main.c",
                    "status": "modified",
                    "additions": 1,
                    "deletions": 1
                }
            ]
        }
    }''')),  # valid response
    ('CVE-1970-1000', 200, b'', None, io.BytesIO(b'')),  # empty response
    ('CVE-1970-1000', 404, b'vcs not found', HTTPError('/', 404, 'vcs not found', {}, io.StringIO('vcs not found')), None),  # not found
    ('CVE-1970-1000', 400, b'something wrong', URLError('something wrong'), None),  # url error
    ('CVE-1970-1500', 404, b'not found', None, 'None'),  # no commit
    ('CVE-1970-9000', 404, b'not found', None, None),  # cve not found
    ('9999', 404, b'not found', None, None),  # id not found
    ('Invalid ID', 404, b'not found', None, None),  # invalid id
]


@pytest.mark.integration
@pytest.mark.parametrize("input_id,expected_status,expected_content", VULN_VIEW_VARIANTS)
def test_view_vulnerability(client, input_id, expected_status, expected_content):
    resp = client.get('/' + input_id)
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize("input_id,expected_status,expected_content", VULN_VIEW_DETAILS_VARIANTS)
def test_view_vulnerability_details(client, input_id, expected_status, expected_content):
    resp = client.get('/{}/details'.format(input_id))
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize("input_id,expected_status,expected_content", VULN_VIEW_ANNOT_VARIANTS)
def test_get_vulnerability_annotation_data(client, input_id, expected_status, expected_content):
    resp = client.get('/{}/annotation_data'.format(input_id))
    assert resp.status_code == expected_status
    assert expected_content in resp.data


################################################################################
# /create as admin. TODO: parameterize the 3 types (admin/user/anonymous)

@pytest.mark.integration
def test_get_new_vuln_page_as_admin(client):
    as_admin(client)
    resp = client.get('/create')
    assert resp.status_code == 200
    assert b'Add a new vulnerability' in resp.data


@pytest.mark.integration
def test_get_update_vuln_page_as_admin(client):
    as_admin(client)
    resp = client.get('/CVE-1970-1000/create')
    assert resp.status_code == 200
    assert b'Add a new vulnerability' in resp.data


@pytest.mark.integration
def test_create_vuln_page_if_nonexisting_as_admin(client):
    as_admin(client)
    resp = client.get('/CVE-1970-9000/create')
    assert resp.status_code == 200
    assert b'Add a new vulnerability' in resp.data


@pytest.mark.integration
def test_create_vuln_page_if_invalid_as_admin(client):
    as_admin(client)
    resp = client.get('/INVALID_ID/create')
    assert resp.status_code == 200
    assert b'Add a new vulnerability' in resp.data


@pytest.mark.integration
def test_delete_vulnerability_entry_as_admin(client):
    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    assert vuln is not None

    as_admin(client)
    resp = client.post('/CVE-1970-1000/create', data={
        'delete_entry': vuln.id,
    })
    assert resp.status_code == 302

    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    assert vuln is None


@pytest.mark.integration
@pytest.mark.parametrize('data,expected_status', CREATE_NEW_VULN_VARIANTS)
def test_create_new_vulnerabilty_as_admin(client, db_engine, db_session, data, expected_status):
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute("SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'").scalar()

    as_admin(client)
    resp = client.post('/create', data=data)
    assert resp.status_code == expected_status
    assert resp.headers.get('Location', '<empty>').endswith(f'/{next_id}')

    vuln = db_session.query(Vulnerability).get(next_id)
    assert vuln.comment == data['comment']
    assert vuln.cve_id == data['cve_id']
    assert len(vuln.commits) == 1
    assert vuln.commits[0].commit_link == data['commits-0-commit_link']
    assert vuln.commits[0].repo_name == data['commits-0-repo_name']
    assert vuln.commits[0].repo_url == data['commits-0-repo_url']
    assert vuln.commits[0].commit_hash == data['commits-0-commit_hash']


@pytest.mark.integration
@pytest.mark.parametrize('data,expected_status,expected_response', CREATE_NEW_VULN_FAIL_VARIANTS)
def test_create_new_vulnerabilty_failure_as_admin(client, db_engine, data, expected_status, expected_response):
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute("SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'").scalar()

    as_admin(client)
    resp = client.post('/create', data=data)
    assert resp.status_code == expected_status
    print(resp.data)
    assert expected_response in resp.data


@pytest.mark.integration
def test_update_vulnerabilty_as_admin(client, db_session):
    data = {
        'cve_id': 'CVE-1970-1000',
        'comment': 'This is the new comment',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }

    as_admin(client)
    resp = client.post('/CVE-1970-1000/create', data=data)
    assert resp.status_code == 302
    assert resp.headers.get('Location', '<empty>').endswith(f'/1')

    vuln = Vulnerability.get_by_id(1)
    assert vuln.comment == data['comment']
    assert vuln.cve_id == data['cve_id']
    assert len(vuln.commits) == 1
    assert vuln.commits[0].commit_link == data['commits-0-commit_link']
    assert vuln.commits[0].repo_name == data['commits-0-repo_name']
    assert vuln.commits[0].repo_url == data['commits-0-repo_url']
    assert vuln.commits[0].commit_hash == data['commits-0-commit_hash']


################################################################################
# /create w/o login

@pytest.mark.integration
def test_get_new_vuln_page(client):
    resp = client.get('/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_get_update_vuln_page(client):
    resp = client.get('/CVE-1970-1000/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_create_vuln_page_if_nonexisting(client):
    resp = client.get('/CVE-1970-9000/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_create_vuln_page_if_invalid(client):
    resp = client.get('/INVALID_ID/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_delete_vulnerability_entry(client):
    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    assert vuln is not None

    resp = client.post('/CVE-1970-1000/create', data={
        'delete_entry': vuln.id,
    })
    assert resp.status_code == 401

    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    assert vuln is not None


@pytest.mark.integration
@pytest.mark.parametrize('data,expected_status', CREATE_NEW_VULN_VARIANTS)
def test_create_new_vulnerabilty(client, db_engine, db_session, data, expected_status):
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute("SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'").scalar()

    resp = client.post('/create', data=data)
    assert resp.status_code == 401

    vuln = db_session.query(Vulnerability).get(next_id)
    assert vuln is None


@pytest.mark.integration
@pytest.mark.parametrize('data,expected_status,expected_response', CREATE_NEW_VULN_FAIL_VARIANTS)
def test_create_new_vulnerabilty_failure(client, db_engine, data, expected_status, expected_response):
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute("SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'").scalar()

    resp = client.post('/create', data=data)
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_update_vulnerabilty(client, db_session):
    data = {
        'cve_id': 'CVE-1970-1000',
        'comment': 'This is the new comment',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }

    resp = client.post('/CVE-1970-1000/create', data=data)
    assert resp.status_code == 401

    vuln = Vulnerability.get_by_id(1)
    assert vuln.comment == 'Vulnerability 1 comment'
    assert vuln.cve_id == data['cve_id']
    assert len(vuln.commits) == 1
    assert vuln.commits[0].commit_link == 'https://github.com/OWNER/REPO1/commit/1234568'
    assert vuln.commits[0].repo_name == 'REPO1'
    assert vuln.commits[0].repo_url == 'https://github.com/OWNER/REPO1'
    assert vuln.commits[0].commit_hash == '1234568'

################################################################################
# /create as user. Only relevant as long as the platform is still readonly

@pytest.mark.integration
def test_get_new_vuln_page_as_user(client):
    as_user(client)
    resp = client.get('/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_get_update_vuln_page_as_user(client):
    as_user(client)
    resp = client.get('/CVE-1970-1000/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_create_vuln_page_if_nonexisting_as_user(client):
    as_user(client)
    resp = client.get('/CVE-1970-9000/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_create_vuln_page_if_invalid_as_user(client):
    as_user(client)
    resp = client.get('/INVALID_ID/create')
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_delete_vulnerability_entry_as_user(client):
    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    assert vuln is not None

    as_user(client)
    resp = client.post('/CVE-1970-1000/create', data={
        'delete_entry': vuln.id,
    })
    assert resp.status_code == 401

    vuln = Vulnerability.get_by_cve_id('CVE-1970-1000')
    assert vuln is not None


@pytest.mark.integration
@pytest.mark.parametrize('data,expected_status', CREATE_NEW_VULN_VARIANTS)
def test_create_new_vulnerabilty_as_user(client, db_engine, db_session, data, expected_status):
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute("SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'").scalar()

    as_user(client)
    resp = client.post('/create', data=data)
    assert resp.status_code == 401

    vuln = db_session.query(Vulnerability).get(next_id)
    assert vuln is None


@pytest.mark.integration
@pytest.mark.parametrize('data,expected_status,expected_response', CREATE_NEW_VULN_FAIL_VARIANTS)
def test_create_new_vulnerabilty_failure_as_user(client, db_engine, data, expected_status, expected_response):
    # use execute+scalar as db_engine is mocked by pytest_flask_sqlalchemy
    next_id = db_engine.execute("SELECT Auto_increment FROM information_schema.tables WHERE table_name='vulnerability'").scalar()

    as_user(client)
    resp = client.post('/create', data=data)
    assert resp.status_code == 401
    assert b'Unauthorized' in resp.data


@pytest.mark.integration
def test_update_vulnerabilty_as_user(client, db_session):
    data = {
        'cve_id': 'CVE-1970-1000',
        'comment': 'This is the new comment',
        'commits-0-commit_link': 'https://github.com/OWNER/REPO/commit/12345678',
        'commits-0-repo_name': 'REPO',
        'commits-0-repo_url': 'https://github.com/OWNER/REPO',
        'commits-0-commit_hash': '12345678',
    }

    as_user(client)
    resp = client.post('/CVE-1970-1000/create', data=data)
    assert resp.status_code == 401

    vuln = Vulnerability.get_by_id(1)
    assert vuln.comment == 'Vulnerability 1 comment'
    assert vuln.cve_id == data['cve_id']
    assert len(vuln.commits) == 1
    assert vuln.commits[0].commit_link == 'https://github.com/OWNER/REPO1/commit/1234568'
    assert vuln.commits[0].repo_name == 'REPO1'
    assert vuln.commits[0].repo_url == 'https://github.com/OWNER/REPO1'
    assert vuln.commits[0].commit_hash == '1234568'

################################################################################


@pytest.mark.integration
@pytest.mark.parametrize("input_id,expected_status,expected_content", VULN_EMBED_VARIANTS)
def test_embed_vulnerabilty(client, input_id, expected_status, expected_content):
    resp = client.get(f'/{input_id}/embed')
    assert resp.status_code == expected_status
    assert expected_content in resp.data


@pytest.mark.integration
@pytest.mark.parametrize("input_id,expected_status,expected_content,side_effect,return_value", VULN_TREE_VARIANTS)
def test_embed_vulnerabilty(client, mocker, input_id, expected_status, expected_content, side_effect, return_value):
    mocked_urlopen = mocker.patch('urllib.request.urlopen')
    mocked_urlopen.side_effect = side_effect
    mocked_urlopen.return_value = return_value

    resp = client.get(f'/{input_id}/tree')
    assert resp.status_code == expected_status
    assert expected_content in resp.data
