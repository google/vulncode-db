# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import itertools
import pytest

from data.models.user import User
from data.models.vulnerability import Vulnerability, VulnerabilityState
from lib.statemachine import NoTransition, TransitionDenied


def admin():
    return User(id=1, email='admin@vulncode-db.com')


def reviewer():
    return User(id=2, email='reviewer@vulncode-db.com')


def creator1():
    return User(id=3, email='creator1@vulncode-db.com')


def creator2():
    return User(id=4, email='creator2@vulncode-db.com')


def build_state_matrix():
    # generate a matrix of all theoretically possible transitions
    state_pairs = set(itertools.permutations(VulnerabilityState, 2))

    # actually implemented cases
    real_pairs = [
        # Entry is sent for review.
        (VulnerabilityState.NEW, VulnerabilityState.READY, None),
        # Feedback gets addressed and entry is sent for review.
        (VulnerabilityState.NEEDS_IMPROVEMENT, VulnerabilityState.READY, None),
        # Entry gets assigned to reviewer.
        (VulnerabilityState.READY, VulnerabilityState.IN_REVIEW,
         TransitionDenied),
        # Invalid transition?
        (VulnerabilityState.IN_REVIEW, VulnerabilityState.NEEDS_IMPROVEMENT,
         TransitionDenied),
        # Reviewer unassigns themselves.
        (VulnerabilityState.IN_REVIEW, VulnerabilityState.READY, None),
        # Reviewer LGTM's entry.
        (VulnerabilityState.IN_REVIEW, VulnerabilityState.REVIEWED, None),
        # Admin publishes entry.
        (VulnerabilityState.REVIEWED, VulnerabilityState.PUBLISHED,
         TransitionDenied),
        # Admin requests improvements.
        (VulnerabilityState.REVIEWED, VulnerabilityState.NEEDS_IMPROVEMENT,
         None),
        # Entry is moved to archive.
        (VulnerabilityState.PUBLISHED, VulnerabilityState.ARCHIVED,
         TransitionDenied),
    ]

    # remove the actual transitions from the matrix
    base_pairs = state_pairs - {(src, dst) for src, dst, _ in real_pairs}

    # set the remaining transitions to raise NoTransition
    base_pairs = [(
        src,
        dst,
        NoTransition,
    ) for src, dst in base_pairs]

    # combine them
    return base_pairs + real_pairs


@pytest.mark.parametrize('src_state,dst_state,exc', build_state_matrix())
def test_state_matrix(src_state, dst_state, exc):
    cr1 = creator1()
    vuln = Vulnerability(state=src_state, creator=cr1)
    if exc:
        with pytest.raises(exc):
            vuln.update_state(dst_state)
    else:
        vuln.update_state(dst_state)


def test_mark_new_as_reviewable():
    cr1 = creator1()
    vuln = Vulnerability(state=VulnerabilityState.NEW, creator=cr1)
    vuln.make_reviewable()

    assert vuln.state == VulnerabilityState.READY
    assert vuln.is_reviewable


def test_mark_needs_improvement_as_reviewable():
    cr1 = creator1()
    vuln = Vulnerability(state=VulnerabilityState.NEEDS_IMPROVEMENT,
                         creator=cr1)
    vuln.make_reviewable()

    assert vuln.state == VulnerabilityState.READY
    assert vuln.is_reviewable


def test_accept_change_after_review():
    vuln = Vulnerability(state=VulnerabilityState.IN_REVIEW)
    vuln.accept_change()

    assert vuln.state == VulnerabilityState.REVIEWED
    assert vuln.is_publishable


def test_deny_change_requires_feedback():
    vuln = Vulnerability(state=VulnerabilityState.IN_REVIEW)

    with pytest.raises(TransitionDenied):
        vuln.update_state(VulnerabilityState.NEEDS_IMPROVEMENT)

    assert vuln.state == VulnerabilityState.IN_REVIEW


def test_deny_reviewed():
    vuln = Vulnerability(state=VulnerabilityState.REVIEWED)
    rev = reviewer()
    vuln.deny_change(rev, 'merge conflict')

    assert vuln.state == VulnerabilityState.NEEDS_IMPROVEMENT
    assert vuln.review_feedback == 'merge conflict'
    assert not vuln.is_publishable
    assert not vuln.is_reviewable


def test_archive_published(mocker):
    # !! mocks all .query getters on all models. Save here as we only use one
    mock_query = mocker.patch(
        'flask_sqlalchemy._QueryProperty.__get__').return_value
    mock_query.filter.return_value.exists.return_value = True
    vuln = Vulnerability(state=VulnerabilityState.PUBLISHED)
    vuln.archive_entry()

    assert vuln.state == VulnerabilityState.ARCHIVED
    assert not vuln.is_publishable
    assert not vuln.is_in_review


def test_archive_requires_published(mocker):
    # !! mocks all .query getters on all models. Save here as we only use one
    mock_query = mocker.patch(
        'flask_sqlalchemy._QueryProperty.__get__').return_value
    mock_query.filter.return_value.first.return_value = False
    vuln = Vulnerability(state=VulnerabilityState.PUBLISHED)

    with pytest.raises(TransitionDenied):
        vuln.archive_entry()

    assert vuln.state == VulnerabilityState.PUBLISHED
    assert not vuln.is_publishable
    assert not vuln.is_in_review


def test_publish_reviewed(mocker):
    mocker.patch.object(Vulnerability,
                        'next_version_number').return_value = 123
    vuln = Vulnerability(state=VulnerabilityState.REVIEWED, version=1)
    vuln.publish_change()

    assert vuln.state == VulnerabilityState.PUBLISHED
    assert vuln.version == 123
    assert not vuln.is_publishable
    assert not vuln.is_in_review


def test_publish_requires_version():
    vuln = Vulnerability(state=VulnerabilityState.REVIEWED)

    with pytest.raises(TransitionDenied):
        vuln.update_state(VulnerabilityState.PUBLISHED)

    assert vuln.state == VulnerabilityState.REVIEWED


def test_return_review_requires_reviewer_reset():
    rev = reviewer()
    vuln = Vulnerability(state=VulnerabilityState.IN_REVIEW, reviewer=rev)

    with pytest.raises(TransitionDenied):
        vuln.update_state(VulnerabilityState.READY)

    assert vuln.state == VulnerabilityState.IN_REVIEW


def test_return_review():
    rev = reviewer()
    vuln = Vulnerability(state=VulnerabilityState.IN_REVIEW, reviewer=rev)
    vuln.return_to_review_pool()

    assert vuln.state == VulnerabilityState.READY
    assert vuln.reviewer is None
    assert not vuln.is_publishable
    assert vuln.is_reviewable


def test_take_review():
    cr1 = creator1()
    rev = reviewer()
    vuln = Vulnerability(state=VulnerabilityState.READY, creator=cr1)
    vuln.accept_review(rev)

    assert vuln.reviewer == rev
    assert vuln.state == VulnerabilityState.IN_REVIEW
    assert vuln.is_reviewer(rev)


def test_take_review_requires_reviewer():
    cr1 = creator1()
    vuln = Vulnerability(state=VulnerabilityState.READY, creator=cr1)
    with pytest.raises(TransitionDenied):
        vuln.update_state(VulnerabilityState.IN_REVIEW)

    assert vuln.state == VulnerabilityState.READY
