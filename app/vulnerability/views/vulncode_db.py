# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from app.vulnerability.views.vulnerability import VulnerabilityView
from app.vulnerability.views.details import VulnerabilityDetails
import re
from flask import request
from flask_sqlalchemy import Pagination

from sqlakeyset import get_page
from sqlakeyset.results import Paging, unserialize_bookmark
from sqlalchemy import func, desc, or_, asc
from data.database import DEFAULT_DATABASE
from data.models.nvd import default_nvd_view_options
from data.models import (
    Description,
    Nvd,
    Vulnerability,
    RepositoryFileComments,
    User,
    RepositoryFileMarkers,
)
db = DEFAULT_DATABASE


class VulncodeDB:
    #
    # def getEntriesWithPatch(self):
    #   cve_entries = select([Nvd, Vulnerability]).select_from(
    #       outerjoin(Nvd, Vulnerability)).apply_labels() #.order_by(desc(Vulnerability.date_created))
    #
    #
    #   # TODO: find performant way to simulate "union" or to deduplicate the
    #   # entries from both data sets... This still takes ~800ms :/...
    #   query_union = db.session.query(Nvd, Vulnerability).select_entity_from(
    #       vcdb_entries.union_all(cve_entries))
    #   #
    #   #cve_entries = db.session.query(Nvd, Vulnerability).outerjoin(Vulnerability)
    #   #query_union = vcdb_entries.union(cve_entries)
    #
    #   #entry = query_union[0]
    #
    #   #entry = entries[0]
    #
    #   #entries = Nvd.get_all_by_link_regex(cfg.PATCH_REGEX)
    #   return query_union

    # @measure_execution_time('Vulncode-DB Constructor')
    def __init__(self):

        self.keyword = None
        # TODO: Look into neabling this once public contributions are enabled.
        # self.top_contributors = []
        # self.fetch_top_contributors()

        vcdb_entries = db.session.query(Vulnerability, Nvd)
        vcdb_entries = vcdb_entries.outerjoin(Nvd, Vulnerability.cve_id == Nvd.cve_id)
        vcdb_entries = vcdb_entries.options(default_nvd_view_options)
        vcdb_entries = vcdb_entries.order_by(asc(Vulnerability.date_created), desc(Vulnerability.id))
        self.vcdb_entries = vcdb_entries

        nvd_entries = db.session.query(Nvd)
        nvd_entries = nvd_entries.outerjoin(Vulnerability, Nvd.cve_id == Vulnerability.cve_id)
        nvd_entries = nvd_entries.options(default_nvd_view_options)
        nvd_entries = nvd_entries.filter(Vulnerability.cve_id.is_(None))
        nvd_entries = nvd_entries.order_by(desc(Nvd.published_date), desc(Nvd.id))
        self.nvd_entries = nvd_entries

        self.keyword = request.args.get("keyword", None, type=str)

        apply_filter = None
        if self.keyword:
            # TODO: Make the filtering work with fulltext search as well.
            if VulnerabilityDetails.is_cve_id(self.keyword):
                apply_filter = or_(False, Nvd.cve_id == self.keyword)
            elif VulnerabilityDetails.is_vcdb_id(self.keyword):
                apply_filter = or_(False, Vulnerability.id == self.keyword)
            else:
                escaped_keyword = self.keyword.replace("%", "")
                # escaped_keyword = re.sub('[\W]+', ' ', self.keyword)
                # Attention: We can't use FullText search here because of some buggy
                # Mysql 5.7 behavior (using FullText on Join results seems is doing bad
                # things. We might need to apply the filter before joining below.
                # apply_filter = or_(
                #     FullTextSearch(escaped_keyword, Nvd, FullTextMode.BOOLEAN),
                #     FullTextSearch(escaped_keyword, Vulnerability, FullTextMode.BOOLEAN))
                apply_filter = or_(
                    Nvd.descriptions.any(Description.value.like("%" + escaped_keyword + "%")),
                    Vulnerability.comment.like("%" + escaped_keyword + "%"),
                )

            # TODO: add product search support.
            # apply_filter = or_(apply_filter, Cpe.product == keyword)

        if apply_filter is not None:
            self.vcdb_entries = self.vcdb_entries.filter(apply_filter)
            self.nvd_entries = self.nvd_entries.filter(apply_filter)

        per_page = 7
        vcdb_page = request.args.get("vcdb_p", 1, type=int)
        self.vcdb_pagination = self.vcdb_entries.paginate(vcdb_page, per_page=per_page)
        self.vcdb_pagination = VulnViewSqlalchemyPaginationObjectWrapper(self.vcdb_pagination)

        def filter_pagination_param(param):
            filtered = re.sub(r'[^a-zA-Z\d\- <>:~]', '', param)
            return filtered

        nvd_bookmarked_page = request.args.get('nvd_p', None)
        if nvd_bookmarked_page:
            nvd_bookmarked_page = filter_pagination_param(nvd_bookmarked_page)
            nvd_bookmarked_page = unserialize_bookmark(nvd_bookmarked_page)

        self.nvd_pagination = get_page(self.nvd_entries, per_page, page=nvd_bookmarked_page)
        self.nvd_pagination = VulnViewTypesetPaginationObjectWrapper(self.nvd_pagination.paging)
        num_nvd_entries = db.session.query(Nvd).count()
        num_vuln_entries = db.session.query(Vulnerability).count()
        num_unique_nvd_estimate = num_nvd_entries - num_vuln_entries
        self.nvd_pagination.set_total(num_unique_nvd_estimate)

    # @measure_execution_time('TOP CONTRIB')
    def fetch_top_contributors(self):
        # TODO: count number of contributions to vulnerabilities instead of single annotations
        num_comments = self.get_annotation_query(RepositoryFileComments)
        num_markers = self.get_annotation_query(RepositoryFileMarkers)
        num_both = num_comments.c.count + num_markers.c.count
        self.top_contributors = (db.session.query(
            User,
            func.coalesce(num_comments.c.count, 0).label("num_comments"),
            func.coalesce(num_markers.c.count, 0).label("num_markers"),
        ).outerjoin(num_comments, num_comments.c.creator_id == User.id).outerjoin(
            num_markers, num_markers.c.creator_id == User.id).filter(num_both > 0).order_by(num_both.desc()).limit(10).all())

    @staticmethod
    def get_annotation_query(model):
        return (db.session.query(model.creator_id.label("creator_id"),
                                 func.count(1).label("count")).filter_by(active=True).group_by(model.creator_id).subquery())

    # @measure_execution_time('NEW 1')
    # def _new_method(self):
    #   files_with_comments = select(
    #       [distinct(RepositoryFileComments.repository_file_id)])
    #   commits_with_comments = db.session.query(
    #       distinct(RepositoryFiles.commit_id)).filter(
    #           RepositoryFiles.id.in_(files_with_comments))
    #   base_query = Vulnerability.query.join(Vulnerability.commits)
    #   self.annotated_entries = base_query.filter(
    #       VulnerabilityGitCommits.id.in_(commits_with_comments)).all()
    #   #self.empty_entries = base_query.filter(
    #   #~VulnerabilityGitCommits.id.in_(commits_with_comments)).all()

    # @measure_execution_time('NEW 2')
    # def _new_method2(self):
    #   base_query = Vulnerability.query.join(
    #       Vulnerability.commits, VulnerabilityGitCommits.repository_files,
    #       RepositoryFiles.comments)
    #   # print base_query.having(func.count(RepositoryFileComments.id) > 0)
    #   self.annotated_entries = base_query.having(
    #       func.count(RepositoryFileComments.id) > 0).all()
    #   self.empty_entries = base_query.having(
    #       func.count(RepositoryFileComments.id) == 0).all()

    # @measure_execution_time('OLD')
    # def _old_method(self):
    #   self.annotated_entries = []
    #   self.empty_entries = []
    #   all_entries = Vulnerability.query.all()
    #
    #   for entry in all_entries:
    #     master_commit = entry.commits[0]
    #     if master_commit.num_comments > 0:
    #       self.annotated_entries.append(entry)
    #     else:
    #       self.empty_entries.append(entry)


def wrap_entries(target_entries):
    """
    Wraps all Vulnerability/Nvd entries into the VulnerabilityView class.
    :return:
    """
    new_entries = []
    if not target_entries:
        return

    first_element = target_entries[0]
    if isinstance(first_element, Nvd):
        for nvd in target_entries:
            vuln_view = VulnerabilityView(None, nvd, preview=True)
            new_entries.append(vuln_view)
    elif isinstance(first_element, Vulnerability):
        for vulnerability in target_entries:
            vuln_view = VulnerabilityView(vulnerability, None, preview=True)
            new_entries.append(vuln_view)
    else:
        for [vulnerability, nvd] in target_entries:
            vuln_view = VulnerabilityView(vulnerability, nvd, preview=True)
            new_entries.append(vuln_view)

    del target_entries[:]
    target_entries.extend(new_entries)


class VulnViewTypesetPaginationObjectWrapper(Paging):
    """
  An sqlakeyset Paging object wrapper class which wraps Vuln/Nvd rows
  inside a VulnView.
  """
    def __init__(self, paginationObject):
        """
    :param paginationObject: A Flask SQLalchemy Pagination object.
    """
        self.__class__ = type(
            paginationObject.__class__.__name__,
            (self.__class__, paginationObject.__class__),
            {},
        )
        self.__dict__ = paginationObject.__dict__
        self.total = 0
        wrap_entries(self.rows)

    def set_total(self, new_total):
        self.total = new_total


class VulnViewSqlalchemyPaginationObjectWrapper(Pagination):
    """
  A Flask SQLAlchemy Pagination object wrapper class which wraps Vuln/Nvd rows
  inside a VulnView.
  """
    def __init__(self, paginationObject):
        """
    :param paginationObject: A Flask SQLalchemy Pagination object.
    """
        self.__class__ = type(
            paginationObject.__class__.__name__,
            (self.__class__, paginationObject.__class__),
            {},
        )
        self.__dict__ = paginationObject.__dict__
        wrap_entries(self.items)
