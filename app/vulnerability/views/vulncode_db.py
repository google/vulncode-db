# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

import sqlakeyset  # type: ignore

from flask import request
from flask_sqlalchemy import Pagination  # type: ignore
from sqlakeyset import get_page
from sqlakeyset.columns import OC  # type: ignore
from sqlakeyset.results import Paging  # type: ignore
from sqlalchemy import func, desc, or_, asc, exc
from sqlalchemy.orm import class_mapper, Mapper

from app.vulnerability.views.details import VulnerabilityDetails
from app.vulnerability.views.vulnerability import VulnerabilityView

from data.database import DEFAULT_DATABASE as db
from data.models import (
    Description,
    Nvd,
    Vulnerability,
    RepositoryFileComments,
    User,
    RepositoryFileMarkers,
)
from data.models.nvd import default_nvd_view_options
from data.models.vulnerability import VulnerabilityState
from lib.utils import parse_pagination_param


def custom_value_from_thing(thing, desc, ocol):  # pylint: disable=redefined-outer-name
    """
    Replacement function for the sqlakeyset value_from_thing method.
    This function supports auto aliasing as is required when sorting by
    columns that appear in subqueries.
    :param thing:
    :param desc:
    :param ocol:
    :return:
    """
    entity = desc["entity"]
    expr = desc["expr"]

    try:
        is_a_table = entity == expr
    except exc.ArgumentError:
        is_a_table = False

    if isinstance(expr, Mapper) and expr.class_ == entity:
        # Is a table mapper. Just treat as a table.
        is_a_table = True

    if is_a_table is True:  # is a table
        mapper = class_mapper(desc["type"])
        base_elem = ocol.element.base_columns
        if not base_elem:
            base_elem = ocol.element
        elif len(base_elem) == 1:
            base_elem = next(iter(base_elem))
        else:
            raise ValueError("Multiple columns")

        # If the OCOL is a hybrid attribute it won't belong to one table.
        if not hasattr(base_elem, "table"):
            raise ValueError

        order_column_table = base_elem.table.name

        if entity.__table__.name == order_column_table:
            prop = mapper.get_property_by_column(base_elem)
            return getattr(thing, prop.key)
        raise ValueError

    # is an attribute
    if hasattr(expr, "info"):
        mapper = expr.parent
        tname = mapper.local_table.description

        if ocol.table_name == tname and ocol.name == expr.name:
            return thing
        raise ValueError

    ocol_quoted_full_name = re.sub("[()]", "", ocol.quoted_full_name)
    # is an attribute with label
    if ocol_quoted_full_name == OC(expr).full_name:
        return thing
    raise ValueError


class VulncodeDB:
    def __init__(self):

        self.keyword = None
        self.top_contributors = []
        # TODO: Look into neabling this once public contributions are enabled.
        # self.fetch_top_contributors()

        has_annotations_col = Vulnerability.has_annotations
        vcdb_entries = db.session.query(Vulnerability, Nvd, has_annotations_col)
        vcdb_entries = vcdb_entries.filter(
            Vulnerability.state == VulnerabilityState.PUBLISHED
        )
        vcdb_entries = vcdb_entries.outerjoin(Nvd, Vulnerability.cve_id == Nvd.cve_id)
        vcdb_entries = vcdb_entries.options(default_nvd_view_options)
        vcdb_entries = vcdb_entries.from_self()
        vcdb_entries = vcdb_entries.order_by(
            desc(has_annotations_col),
            asc(Vulnerability.date_created),
            desc(Vulnerability.id),
        )
        self.vcdb_entries = vcdb_entries

        nvd_entries = db.session.query(Nvd)
        nvd_entries = nvd_entries.outerjoin(
            Vulnerability, Nvd.cve_id == Vulnerability.cve_id
        )
        nvd_entries = nvd_entries.options(default_nvd_view_options)
        nvd_entries = nvd_entries.filter(Vulnerability.cve_id.is_(None))
        nvd_entries = nvd_entries.order_by(desc(Nvd.published_date), desc(Nvd.id))
        self.nvd_entries = nvd_entries

        self.keyword = request.args.get("keyword", None, type=str)

        apply_filter = None
        if self.keyword:
            # TODO: Make the filtering work with fulltext search as well.
            if VulnerabilityDetails.is_cve_id(self.keyword):
                apply_filter = or_(False, Nvd.cve_id == self.keyword)
            elif VulnerabilityDetails.is_vcdb_id(self.keyword):
                apply_filter = or_(False, Vulnerability.id == self.keyword)
            else:
                escaped_keyword = self.keyword.replace("%", "")
                # escaped_keyword = re.sub('[\W]+', ' ', self.keyword)
                # Attention: We can't use FullText search here because of some
                # buggy Mysql 5.7 behavior (using FullText on Join results seems
                # is doing bad things. We might need to apply the filter before
                # joining below.
                # apply_filter = or_(
                #     FullTextSearch(escaped_keyword, Nvd,
                #                    FullTextMode.BOOLEAN),
                #     FullTextSearch(escaped_keyword, Vulnerability,
                #                    FullTextMode.BOOLEAN))
                apply_filter = or_(
                    Nvd.descriptions.any(
                        Description.value.like("%" + escaped_keyword + "%")
                    ),
                    Vulnerability.comment.like("%" + escaped_keyword + "%"),
                )

            # TODO: add product search support.
            # apply_filter = or_(apply_filter, Cpe.product == keyword)

        if apply_filter is not None:
            self.vcdb_entries = self.vcdb_entries.filter(apply_filter)
            self.nvd_entries = self.nvd_entries.filter(apply_filter)

        per_page = 7
        vcdb_bookmarked_page = parse_pagination_param("vcdb_p")
        # Replace a sqlakeyset function to support our use case.
        # TODO: File a PR for this?
        sqlakeyset.paging.value_from_thing = custom_value_from_thing
        self.vcdb_pagination = get_page(
            self.vcdb_entries, per_page, page=vcdb_bookmarked_page
        )
        self.vcdb_pagination = VulnViewTypesetPaginationObjectWrapper(
            self.vcdb_pagination.paging
        )
        num_vuln_entries = db.session.query(func.count(Vulnerability.id)).scalar()
        self.vcdb_pagination.set_total(num_vuln_entries)

        nvd_bookmarked_page = parse_pagination_param("nvd_p")
        self.nvd_pagination = get_page(
            self.nvd_entries, per_page, page=nvd_bookmarked_page
        )
        self.nvd_pagination = VulnViewTypesetPaginationObjectWrapper(
            self.nvd_pagination.paging
        )
        num_nvd_entries = db.session.query(func.count(Nvd.id)).scalar()
        num_unique_nvd_estimate = num_nvd_entries - num_vuln_entries
        self.nvd_pagination.set_total(num_unique_nvd_estimate)

    def fetch_top_contributors(self):
        # TODO: count number of contributions to vulnerabilities instead of
        # single annotations
        num_comments = self.get_annotation_query(RepositoryFileComments)
        num_markers = self.get_annotation_query(RepositoryFileMarkers)
        num_both = num_comments.c.count + num_markers.c.count
        self.top_contributors = (
            db.session.query(
                User,
                func.coalesce(num_comments.c.count, 0).label("num_comments"),
                func.coalesce(num_markers.c.count, 0).label("num_markers"),
            )
            .outerjoin(num_comments, num_comments.c.creator_id == User.id)
            .outerjoin(num_markers, num_markers.c.creator_id == User.id)
            .filter(num_both > 0)
            .order_by(num_both.desc())
            .limit(10)
            .all()
        )

    @staticmethod
    def get_annotation_query(model):
        return (
            db.session.query(
                model.creator_id.label("creator_id"), func.count(1).label("count")
            )
            .filter_by(active=True)
            .group_by(model.creator_id)
            .subquery()
        )


def wrap_entries(target_entries):
    """
    Wraps all Vulnerability/Nvd entries into the VulnerabilityView class.
    :return:
    """
    new_entries = []
    if not target_entries:
        return

    first_element = target_entries[0]
    if isinstance(first_element, Nvd):
        for nvd in target_entries:
            vuln_view = VulnerabilityView(None, nvd, preview=True)
            new_entries.append(vuln_view)
    elif isinstance(first_element, Vulnerability):
        for vulnerability in target_entries:
            vuln_view = VulnerabilityView(vulnerability, None, preview=True)
            new_entries.append(vuln_view)
    else:
        for columns in target_entries:
            vulnerability = columns[0]
            nvd = columns[1]
            if len(columns) > 2 and isinstance(columns[2], bool):
                annotation_exists = columns[2]
                vulnerability.set_has_annotations(annotation_exists)

            vuln_view = VulnerabilityView(vulnerability, nvd, preview=True)
            new_entries.append(vuln_view)

    del target_entries[:]
    target_entries.extend(new_entries)


class VulnViewTypesetPaginationObjectWrapper(Paging):
    """
    An sqlakeyset Paging object wrapper class which wraps Vuln/Nvd rows
    inside a VulnView.
    """

    def __init__(self, pagination_object):  # pylint: disable=super-init-not-called
        """
        :param pagination_object: A Flask SQLalchemy Pagination object.
        """
        # hot patching the class instance, therefore no super() call
        self.__class__ = type(
            pagination_object.__class__.__name__,
            (self.__class__, pagination_object.__class__),
            {},
        )
        self.__dict__ = pagination_object.__dict__
        self.total = 0
        wrap_entries(self.rows)

    def set_total(self, new_total):
        self.total = new_total


class VulnViewSqlalchemyPaginationObjectWrapper(Pagination):
    """
    A Flask SQLAlchemy Pagination object wrapper class which wraps Vuln/Nvd rows
    inside a VulnView.
    """

    def __init__(self, pagination_object):  # pylint: disable=super-init-not-called
        """
        :param pagination_object: A Flask SQLalchemy Pagination object.
        """
        # hot patching the class instance, therefore no super() call
        self.__class__ = type(
            pagination_object.__class__.__name__,
            (self.__class__, pagination_object.__class__),
            {},
        )
        self.__dict__ = pagination_object.__dict__
        wrap_entries(self.items)
