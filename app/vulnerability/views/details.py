# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import inspect
import json
import logging
import re
import ssl
import urllib.error
import urllib.parse
import urllib.request

from app.vulnerability.views.vulnerability import VulnerabilityView

from flask import current_app, request, url_for, g
from werkzeug.routing import RequestRedirect
from app.exceptions import InvalidIdentifierException
import cfg
from data.database import DEFAULT_DATABASE
from data.models import (
    Nvd,
    RepositoryFilesSchema,
    Vulnerability,
    VulnerabilityGitCommits,
)
from lib.vcs_management import (
    get_vcs_handler,
    VULN_ID_PLACEHOLDER,
    HASH_PLACEHOLDER,
    PATH_PLACEHOLDER,
)

db = DEFAULT_DATABASE


class VulnerabilityDetails:
    def __init__(self, vuln_id=None):
        self.suggested_id = vuln_id
        self.id = None
        self.vcdb_id = None
        self.cve_id = None
        self.commit_link = None
        self.commit_hash = None
        self.repo_url = None
        self.repo_name = None
        self._vulnerability = None
        self._nvd_data = None
        self.tree_url = None
        self.file_url = None
        self.file_provider_url = None
        self.file_ref_provider_url = None
        self.vulnerability_view = None

        self.populate_from_request()
        logging.debug("Loaded vulnerability details %r", self)

    def __repr__(self):
        args = [
            f"{name}={value!r}"
            for name, value in inspect.getmembers(self, lambda m: not inspect.isfunction(m) and not inspect.ismethod(m))
            if not name.startswith("_")
        ]
        return f"{type(self).__name__}({', '.join(args)})"

    def update_details(self):
        """
        Updates the database with pending vuln + dependencies modifications.
        """
        db.session.add(self._vulnerability)
        db.session.commit()

    def get_nvd_entry(self):
        return self._nvd_data

    def populate_from_request(self):
        if not self.suggested_id:
            self.suggested_id = request.args.get("id", None, type=str)
        if not self.suggested_id:
            self.suggested_id = request.form.get("id", None, type=str)

        self.id = None
        self.vcdb_id = request.args.get("vcdb_id", None, type=str)
        self.cve_id = request.args.get("cve_id", None, type=str)
        self.commit_link = request.form.get("commit_link", None, type=str)
        self.commit_hash = request.form.get("commit_hash", None, type=str)
        self.repo_url = request.form.get("repo_url", None, type=str)
        self.repo_name = None
        self._vulnerability = None
        self._nvd_data = None
        self.file_provider_url = None
        self.file_ref_provider_url = None
        self.vulnerability_view = None

        # The suggested id will overwrite other identifiers accordingly.
        if self.suggested_id:
            if self.is_cve_id(self.suggested_id):
                self.cve_id = self.suggested_id
                logging.debug("Suggested id %r recognized as CVE", self.suggested_id)
            elif self.is_vcdb_id(self.suggested_id):
                self.vcdb_id = self.suggested_id
                logging.debug("Suggested id %r recognized as VCDB_ID", self.suggested_id)
            if request.method == "POST":
                # Handle more complex IDs only via POST.
                if self.is_commit_link(self.suggested_id):
                    self.commit_link = self.suggested_id
                    logging.debug("Suggested id %r recognized as commit link", self.suggested_id)
                elif self.is_repo_data(self.suggested_id):
                    repo_data = self.suggested_id.split("||")
                    self.repo_url = repo_data[0]
                    self.commit_hash = repo_data[1]
                    logging.debug("Suggested id %r recognized as raw repo link", self.suggested_id)

        self._fetch_data()

    def populate_from_model(self, model):
        self._vulnerability = model
        self.cve_id = model.cve_id
        self.vcdb_id = model.id
        self.commit_hash = model.master_commit.commit_hash
        self.commit_link = model.master_commit.commit_link
        self.repo_url = model.master_commit.repo_url
        self.repo_name = model.master_commit.repo_name

    def validate(self):
        self._set_id()
        if not self.id:
            raise InvalidIdentifierException("Please provide a valid CVE ID or Git commit link.")

        # if request.path is '/vuln':
        #  if self.cve_id or self.vcdb_id:
        #    pass
        #    #use_endpoint = 'vuln.vuln_view'

        # Always redirect to the most simple URL.
        if request.method == "GET":
            if not self.suggested_id or self.suggested_id != self.id:
                raise RequestRedirect("/" + str(self.id))

    def _set_id(self):
        """Sets the most recognizable ID according to a priority list."""
        # repo_data = None
        # if self.repo_url and self.commit_hash:
        #  repo_data = self.repo_url + '||' + self.commit_hash
        priority_list = [self.cve_id, self.vcdb_id]
        for identifier in priority_list:
            if identifier is not None:
                self.id = identifier
                return
        self.id = None

    def getSettings(self):
        parent_hash = (None, )
        if self.vulnerability_view:
            parent_hash = self.vulnerability_view.parent_commit

        file_provider_url = self.file_provider_url
        if file_provider_url:
            file_provider_url = self.file_provider_url.replace(VULN_ID_PLACEHOLDER, self.id)
        file_ref_provider_url = self.file_ref_provider_url
        if file_ref_provider_url:
            file_ref_provider_url = self.file_ref_provider_url.replace(VULN_ID_PLACEHOLDER, self.id)

        data = {
            "commit_link": self.commit_link,
            "commit_hash": self.commit_hash,
            "repo_url": self.repo_url,
            "repo_name": self.repo_name,
            "tree_url": url_for("vuln.vuln_file_tree", vuln_id=self.id),
            "annotation_data_url": url_for("vuln.annotation_data", vuln_id=self.id),
            "file_provider_url": file_provider_url,
            "file_ref_provider_url": file_ref_provider_url,
            "file_url": self.file_url,
            "id": self.id,
            "parent_hash": parent_hash,
            "HASH_PLACEHOLDER": HASH_PLACEHOLDER,
            "PATH_PLACEHOLDER": PATH_PLACEHOLDER,
        }
        if self.vulnerability_view.annotated:
            master_commit = self.getMasterCommit()
            if master_commit:
                files_schema = RepositoryFilesSchema(many=True)
                # TODO: Consider refactoring this section. We currently also fetch
                #  custom data from the backend.
                # Hack to quickly retrieve the full data.
                data["custom_data"] = json.loads(files_schema.jsonify(master_commit.repository_files).data)

        return data

    def hasCustomData(self):
        master_commit = self.getMasterCommit()
        if not master_commit or not master_commit.repository_files:
            return False
        files_schema = RepositoryFilesSchema(many=True)
        custom_data = files_schema.dump(master_commit.repository_files).data
        return custom_data

    def getMasterCommit(self):
        if not self._vulnerability:
            return None
        return self._vulnerability.master_commit

    def _init_repo_data(self):
        if self.commit_link and "github.com" in self.commit_link:
            resource_url = self.commit_link
        else:
            resource_url = self.repo_url if self.repo_url else self.commit_link

        logging.info(f"Searching VCS handler for {resource_url}")
        if not resource_url:
            return False

        vcs_handler = get_vcs_handler(current_app, resource_url)
        if not vcs_handler:
            raise InvalidIdentifierException("Please provide a valid resource link.")
        self.repo_name = vcs_handler.repo_name
        self.file_provider_url = vcs_handler.getFileProviderUrl()
        self.file_ref_provider_url = vcs_handler.getRefFileProviderUrl()
        self.file_url = vcs_handler.getFileUrl()
        self.tree_url = vcs_handler.getTreeUrl()
        self.commit_hash = (self.commit_hash if self.commit_hash else vcs_handler.commit_hash)
        if not self.commit_hash:
            raise InvalidIdentifierException("Couldn't extract commit hash from given resource URL.")
        return True

    @staticmethod
    def is_cve_id(id):
        # strict check from https://cve.mitre.org/cve/identifiers/tech-guidance.html
        return (re.match(r"^CVE-\d{4}-(0\d{3}|[1-9]\d{3,})$", id, re.IGNORECASE) is not None)

    @staticmethod
    def is_vcdb_id(id):
        return id.isdigit()

    @staticmethod
    def is_commit_link(id):
        return re.match(r".*github.com/", id) is not None

    @staticmethod
    def is_repo_data(id):
        return "||" in id

    def _fetch_by_id(self):
        if self.vcdb_id:
            self._vulnerability = Vulnerability.get_by_id(self.vcdb_id)
        elif self.cve_id:
            if not self.is_cve_id(self.cve_id):
                raise InvalidIdentifierException("Please provide a valid CVE ID.")
            self._vulnerability = Vulnerability.get_by_cve_id(self.cve_id)

    def _fetch_by_commit_hash(self):
        if self._vulnerability or not self.commit_hash:
            return
        self._vulnerability = Vulnerability.get_by_commit_hash(self.commit_hash)

    def fetch_tree_cache(self, skip_errors=True, max_timeout=4):
        """
    (Pre)fetches / updates the file tree cache if required and possible.
    """
        master_commit = self.getMasterCommit()
        if master_commit and not master_commit.tree_cache:
            # Fetch the required data from our VCS proxy.
            try:
                # Fetch the required data from our VCS proxy.
                proxy_target = (cfg.GCE_VCS_PROXY_URL + url_for(
                    "vcs_proxy.main_api",
                    commit_link=self.commit_link,
                    commit_hash=self.commit_hash,
                    repo_url=self.repo_url,
                )[1:])

                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.load_verify_locations(cafile=cfg.APP_CERT_FILE)
                ctx.verify_mode = ssl.CERT_REQUIRED
                result = urllib.request.urlopen(proxy_target, timeout=max_timeout, context=ctx)
                master_commit.tree_cache = result.read()
                self.update_details()
            except Exception as e:
                if not skip_errors:
                    raise e

    def _fetch_data(self):
        self._fetch_by_id()
        commit = self.getMasterCommit()
        if commit:
            commit = self._vulnerability.master_commit
            self.commit_link = commit.commit_link
            self.commit_hash = commit.commit_hash
            self.repo_url = commit.repo_url
        # Initialize VCS specific data.
        self._init_repo_data()
        self._fetch_by_commit_hash()

        # Fetch IDs from vulnerability entry if it exists.
        if self._vulnerability:
            self.vcdb_id = str(self._vulnerability.id)
            if self._vulnerability.cve_id:
                self.cve_id = self._vulnerability.cve_id

        # Fetch corresponding NVD data if possible.
        if self.cve_id:
            self._nvd_data = Nvd.get_by_cve_id(self.cve_id)
        elif self.commit_hash:
            self._nvd_data = Nvd.get_by_commit_hash(self.commit_hash)

        # Make sure to always use the properly formatted CVE-ID if available.
        if self._nvd_data:
            self.cve_id = self._nvd_data.cve_id

        if self._vulnerability or self._nvd_data:
            self.fetch_tree_cache()
            self.vulnerability_view = VulnerabilityView(self._vulnerability, self._nvd_data)

    def get_or_create_vulnerability(self):
        if self._vulnerability:
            return self._vulnerability

        default_cve_id = None
        if self._nvd_data is not None:
            default_cve_id = self._nvd_data.cve_id
        return Vulnerability(
            cve_id=default_cve_id,
            commits=[
                VulnerabilityGitCommits(
                    commit_link=self.commit_link,
                    repo_name=self.repo_name,
                    repo_url=self.repo_url,
                    commit_hash=self.commit_hash,
                )
            ],
            comment="",
            creator=g.user,
        )
