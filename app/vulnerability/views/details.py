# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import inspect
import json
import logging
import re
import ssl
import urllib.error
import urllib.parse
import urllib.request

from typing import Optional

from flask import current_app, request, url_for, g

import cfg

from app.exceptions import InvalidIdentifierException
from app.vulnerability.views.vulnerability import VulnerabilityView
from data.database import DEFAULT_DATABASE as db
from data.models import (
    Nvd,
    RepositoryFilesSchema,
    Vulnerability,
    VulnerabilityGitCommits,
)
from lib.utils import RequestRedirect
from lib.vcs_management import (
    get_vcs_handler,
    VCDB_ID_PLACEHOLDER,
    HASH_PLACEHOLDER,
    PATH_PLACEHOLDER,
)


class VulnerabilityDetails:  # pylint: disable=too-many-instance-attributes
    def __init__(self, suggested_id=None, vuln_id=None):
        self.suggested_id = suggested_id
        self.id = None
        self.vcdb_id = None
        self.vuln_id = vuln_id
        self.cve_id = None
        self.commit_link = None
        self.commit_hash = None
        self.repo_url = None
        self.repo_name = None
        self._vulnerability = None
        self._nvd_data = None
        self.tree_url = None
        self.file_url = None
        self.file_provider_url = None
        self.file_ref_provider_url = None
        self.vulnerability_view: Optional[VulnerabilityView] = None

        self.populate_from_request()
        logging.debug("Loaded vulnerability details %r", self)
        self._set_id()

    def __repr__(self):
        args = [
            f"{name}={value!r}"
            for name, value in inspect.getmembers(
                self, lambda m: not inspect.isfunction(m) and not inspect.ismethod(m)
            )
            if not name.startswith("_")
        ]
        return f"{type(self).__name__}({', '.join(args)})"

    def update_details(self):
        """
        Updates the database with pending vuln + dependencies modifications.
        """
        db.session.add(self._vulnerability)
        db.session.commit()

    def get_nvd_entry(self):
        return self._nvd_data

    def populate_from_request(self):
        if not self.suggested_id:
            self.suggested_id = request.args.get("id", None, type=str)
        if not self.suggested_id:
            self.suggested_id = request.form.get("id", None, type=str)

        self.id = None
        self.vcdb_id = request.args.get("vcdb_id", None, type=str)
        self.cve_id = request.args.get("cve_id", None, type=str)
        self.commit_link = request.form.get("commit_link", None, type=str)
        self.commit_hash = request.form.get("commit_hash", None, type=str)
        self.repo_url = request.form.get("repo_url", None, type=str)
        self.repo_name = None
        self._vulnerability = None
        self._nvd_data = None
        self.file_provider_url = None
        self.file_ref_provider_url = None
        self.vulnerability_view = None

        # The suggested id will overwrite other identifiers accordingly.
        if self.suggested_id:
            if self.is_cve_id(self.suggested_id):
                self.cve_id = self.suggested_id
                logging.debug("Suggested id %r recognized as CVE", self.suggested_id)
            elif self.is_vcdb_id(self.suggested_id):
                self.vcdb_id = self.suggested_id
                logging.debug(
                    "Suggested id %r recognized as VCDB_ID", self.suggested_id
                )
            if request.method == "POST":
                # Handle more complex IDs only via POST.
                if self.is_commit_link(self.suggested_id):
                    self.commit_link = self.suggested_id
                    logging.debug(
                        "Suggested id %r recognized as commit link", self.suggested_id
                    )
                elif self.is_repo_data(self.suggested_id):
                    repo_data = self.suggested_id.split("||")
                    self.repo_url = repo_data[0]
                    self.commit_hash = repo_data[1]
                    logging.debug(
                        "Suggested id %r recognized as raw repo link", self.suggested_id
                    )

        self._fetch_data()

    def populate_from_model(self, model):
        self._vulnerability = model
        self.cve_id = model.cve_id
        self.vcdb_id = model.id
        self.commit_hash = model.master_commit.commit_hash
        self.commit_link = model.master_commit.commit_link
        self.repo_url = model.master_commit.repo_url
        self.repo_name = model.master_commit.repo_name

    def validate_and_simplify_id(self):
        if not self.id:
            raise InvalidIdentifierException(
                "Please provide a valid CVE ID or Git commit link."
            )
        # if request.path is '/vuln':
        #  if self.cve_id or self.vcdb_id:
        #    pass
        #    #use_endpoint = 'vuln.vuln_view'

        # Always redirect to the most simple URL.
        if request.method == "GET":
            if not self.suggested_id or self.suggested_id != self.id:
                raise RequestRedirect("/" + str(self.id))

    def _set_id(self):
        """Sets the most recognizable ID according to a priority list."""
        # repo_data = None
        # if self.repo_url and self.commit_hash:
        #  repo_data = self.repo_url + '||' + self.commit_hash
        priority_list = [self.cve_id, self.vcdb_id]
        for identifier in priority_list:
            if identifier is not None:
                self.id = identifier
                return

    def get_settings(self):
        if not self.id:
            return {}
        parent_hash = (None,)
        if self.vulnerability_view:
            parent_hash = self.vulnerability_view.parent_commit

        file_provider_url = self.file_provider_url
        if file_provider_url:
            file_provider_url = self.file_provider_url.replace(
                VCDB_ID_PLACEHOLDER, self.id
            )
        file_ref_provider_url = self.file_ref_provider_url
        if file_ref_provider_url:
            file_ref_provider_url = self.file_ref_provider_url.replace(
                VCDB_ID_PLACEHOLDER, self.id
            )

        data = {
            "commit_link": self.commit_link,
            "commit_hash": self.commit_hash,
            "repo_url": self.repo_url,
            "repo_name": self.repo_name,
            "tree_url": url_for("vuln.vuln_file_tree", vcdb_id=self.id),
            "annotation_data_url": url_for("vuln.annotation_data", vcdb_id=self.id),
            "file_provider_url": file_provider_url,
            "file_ref_provider_url": file_ref_provider_url,
            "file_url": self.file_url,
            "id": self.id,
            "parent_hash": parent_hash,
            "HASH_PLACEHOLDER": HASH_PLACEHOLDER,
            "PATH_PLACEHOLDER": PATH_PLACEHOLDER,
        }
        if self.vulnerability_view and self.vulnerability_view.annotated:
            master_commit = self.get_master_commit()
            if master_commit:
                files_schema = RepositoryFilesSchema(many=True)
                # TODO: Consider refactoring this section. We currently also
                # fetch custom data from the backend.
                # Hack to quickly retrieve the full data.
                data["custom_data"] = json.loads(
                    files_schema.jsonify(master_commit.repository_files).data
                )

        return data

    def has_custom_data(self):
        master_commit = self.get_master_commit()
        if not master_commit or not master_commit.repository_files:
            return False
        files_schema = RepositoryFilesSchema(many=True)
        custom_data = files_schema.dump(master_commit.repository_files).data
        return custom_data

    def get_master_commit(self):
        if not self._vulnerability:
            return None
        return self._vulnerability.master_commit

    def _init_repo_data(self):
        if self.commit_link and "github.com" in self.commit_link:
            resource_url = self.commit_link
        else:
            resource_url = self.repo_url if self.repo_url else self.commit_link

        logging.info("Searching VCS handler for %s", resource_url)
        if not resource_url:
            return False

        vcs_handler = get_vcs_handler(current_app, resource_url)
        if not vcs_handler:
            raise InvalidIdentifierException("Please provide a valid resource link.")
        self.repo_name = vcs_handler.repo_name
        self.file_provider_url = vcs_handler.get_file_provider_url()
        self.file_ref_provider_url = vcs_handler.get_ref_file_provider_url()
        self.file_url = vcs_handler.get_file_url()
        self.tree_url = vcs_handler.get_tree_url()
        self.commit_hash = (
            self.commit_hash if self.commit_hash else vcs_handler.commit_hash
        )
        if not self.commit_hash:
            raise InvalidIdentifierException(
                "Couldn't extract commit hash from given resource URL."
            )
        return True

    @staticmethod
    def is_cve_id(cve_id):
        # strict check from
        # https://cve.mitre.org/cve/identifiers/tech-guidance.html
        return (
            re.match(r"^CVE-\d{4}-(0\d{3}|[1-9]\d{3,})$", cve_id, re.IGNORECASE)
            is not None
        )

    @staticmethod
    def is_vcdb_id(vcdb_id):
        return vcdb_id.isdigit()

    @staticmethod
    def is_commit_link(link):
        return re.match(r".*github.com/", link) is not None

    @staticmethod
    def is_repo_data(data):
        return "||" in data

    def _fetch_by_id(self):
        if self.vuln_id:
            logging.debug("Loading vuln by vulnid %r", self.vuln_id)
            self._vulnerability = Vulnerability.get_by_id(self.vuln_id)
        elif self.vcdb_id:
            logging.debug("Loading vuln by vcdbid %r", self.vcdb_id)
            self._vulnerability = Vulnerability.get_by_vcdb_id(self.vcdb_id)
        elif self.cve_id:
            logging.debug("Loading vuln by cveid %r", self.cve_id)
            logging.warning("No identifier available to load vulnerability entry")
            if not self.is_cve_id(self.cve_id):
                raise InvalidIdentifierException("Please provide a valid CVE ID.")
            self._vulnerability = Vulnerability.get_by_cve_id(self.cve_id)
        else:
            logging.warning("No identifier available to load vulnerability entry")

    def _fetch_by_commit_hash(self):
        if self._vulnerability or not self.commit_hash:
            return
        self._vulnerability = Vulnerability.get_by_commit_hash(self.commit_hash)

    def fetch_tree_cache(self, skip_errors=True, max_timeout=4):
        """
        (Pre)fetches / updates the file tree cache if required and possible.
        """
        master_commit = self.get_master_commit()
        if master_commit and not master_commit.tree_cache:
            # Fetch the required data from our VCS proxy.
            try:
                # Fetch the required data from our VCS proxy.
                proxy_target = cfg.GCE_VCS_PROXY_URL + url_for(
                    "vcs_proxy.main_api",
                    commit_link=self.commit_link,
                    commit_hash=self.commit_hash,
                    repo_url=self.repo_url,
                )[1:]

                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.load_verify_locations(cafile=cfg.APP_CERT_FILE)
                ctx.verify_mode = ssl.CERT_REQUIRED
                result = urllib.request.urlopen(  # nosec
                    proxy_target, timeout=max_timeout, context=ctx
                )
                master_commit.tree_cache = result.read()
                self.update_details()
            except Exception:  # pylint: disable=broad-except
                if not skip_errors:
                    raise

    def _fetch_data(self):
        self._fetch_by_id()
        commit = self.get_master_commit()
        if commit:
            commit = self._vulnerability.master_commit
            self.commit_link = commit.commit_link
            self.commit_hash = commit.commit_hash
            self.repo_url = commit.repo_url
        # Initialize VCS specific data.
        self._init_repo_data()
        self._fetch_by_commit_hash()

        # Fetch IDs from vulnerability entry if it exists.
        if self._vulnerability:
            self.vcdb_id = str(self._vulnerability.vcdb_id)
            self.vuln_id = str(self._vulnerability.id)
            if self._vulnerability.cve_id:
                self.cve_id = self._vulnerability.cve_id

        # Fetch corresponding NVD data if possible.
        if self.cve_id:
            self._nvd_data = Nvd.get_by_cve_id(self.cve_id)
        elif self.commit_hash:
            self._nvd_data = Nvd.get_by_commit_hash(self.commit_hash)

        # Make sure to always use the properly formatted CVE-ID if available.
        if self._nvd_data:
            self.cve_id = self._nvd_data.cve_id

        if self._vulnerability or self._nvd_data:
            self.fetch_tree_cache()
            self.vulnerability_view = VulnerabilityView(
                self._vulnerability, self._nvd_data
            )

    def get_vulnerability(self) -> Optional[Vulnerability]:
        return self._vulnerability

    def get_or_create_vulnerability(self) -> Vulnerability:
        if self._vulnerability:
            return self._vulnerability
        logging.debug("Vulnerability not found creating new instance")
        default_cve_id = None
        if self._nvd_data is not None:
            default_cve_id = self._nvd_data.cve_id
        default_vulnerability = Vulnerability(
            cve_id=default_cve_id,
            commits=[
                VulnerabilityGitCommits(
                    commit_link=self.commit_link,
                    repo_name=self.repo_name,
                    repo_url=self.repo_url,
                    commit_hash=self.commit_hash,
                )
            ],
            comment="",
            creator=g.user,
        )
        return default_vulnerability
