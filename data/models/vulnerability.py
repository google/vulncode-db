# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import logging
import json

from sqlalchemy.ext.hybrid import hybrid_property

from app.exceptions import InvalidIdentifierException

from data.utils import populate_models
from data.models.base import MainBase, ma
from data.models.user import User
from sqlalchemy import (Boolean, Column, Integer, Enum, String, Text,
                        ForeignKey, Index, DateTime, func, UniqueConstraint,
                        ForeignKeyConstraint)
from sqlalchemy.dialects.mysql import LONGTEXT
from sqlalchemy.orm import relationship, deferred, joinedload
from lib.vcs_management import get_vcs_handler
from lib.statemachine import StateMachine, transition, event

import marshmallow

LOG = logging.getLogger(__name__)


class VulnerabilityState(StateMachine):
    NEW = 0
    READY = 1
    IN_REVIEW = 2
    REVIEWED = 3
    PUBLISHED = 4
    ARCHIVED = 5

    @event(NEW)
    def on_new(self):
        LOG.info('Vulnerability entered NEW state')

    new_to_ready = transition(NEW, READY)()
    ready_to_review = transition(READY, IN_REVIEW)()
    review_to_new = transition(IN_REVIEW, NEW)()
    review_to_reviewed = transition(IN_REVIEW, REVIEWED)()
    reviewed_to_new = transition(REVIEWED, NEW)()
    published_to_archived = transition(PUBLISHED, ARCHIVED)()

    @transition(REVIEWED, PUBLISHED)
    def check_publishing_possible(self, current_state, next_state):
        # TODO: check for merge conflicts or other issues
        pass


class RevisionMixin:
    revision = Column(Integer, nullable=False, default=0)
    active = Column(Boolean, nullable=False, default=True)
    archived_at = Column(DateTime)

    def archive(self):
        self.active = False
        self.archived_at = datetime.datetime.utcnow()

    def to_json(self):
        """Serialize object properties as dict."""
        return {
            'revision': self.revision,
            'active': self.active,
            'archived_at': self.archived_at
        }


class MarshmallowBase(ma.ModelSchema):

    __abstract__ = True

    class Meta:
        exclude = ("id", "date_created", "date_modified")


# TODO: Enable this once custom resource links are supported again.
class VulnerabilityResources(MainBase):
    link = Column(String(255), nullable=False)

    #vulnerability_details_id = Column(Integer, ForeignKey("vulnerability.id"))

    def to_json(self):
        """Serialize object properties as dict."""
        return {
            'id': self.id,
            'date_created': self.date_created,
            'date_modified': self.date_modified,
            'link': self.link,
            'vulnerability_details_id': self.vulnerability_details_id
        }


class CreatorSchema(MarshmallowBase):
    class Meta:
        model = User


class RepositoryFileMarkers(RevisionMixin, MainBase):
    __tablename__ = "repository_file_markers"
    row_from = Column(Integer)
    row_to = Column(Integer)
    column_from = Column(Integer)
    column_to = Column(Integer)
    marker_class = Column(String(100), nullable=False)
    repository_file_id = Column(Integer, ForeignKey("repository_files.id"))
    creator_id = Column(Integer, ForeignKey(User.id), nullable=True)
    creator = relationship(User, lazy="joined", uselist=False)


class RepositoryFileMarkersSchema(MarshmallowBase):
    class Meta(MarshmallowBase.Meta):
        model = RepositoryFileMarkers

    creator = marshmallow.fields.Nested(CreatorSchema)


class RepositoryFileComments(RevisionMixin, MainBase):
    __tablename__ = "repository_file_comments"
    row_from = Column(Integer)
    row_to = Column(Integer)
    text = Column(Text, nullable=False)
    sort_pos = Column(Integer)
    repository_file_id = Column(Integer, ForeignKey("repository_files.id"))
    creator_id = Column(Integer, ForeignKey(User.id), nullable=True)
    creator = relationship(User, lazy="joined", uselist=False)


class RepositoryFileCommentsSchema(MarshmallowBase):
    class Meta(MarshmallowBase.Meta):
        model = RepositoryFileComments
        exclude = ["archived_at", "active"]

    creator = marshmallow.fields.Nested(CreatorSchema)


class RepositoryFiles(MainBase):
    __tablename__ = "repository_files"
    file_name = Column(String(255), nullable=False)
    file_path = Column(String(255), nullable=False)
    file_hash = Column(String(255), nullable=False)
    # A cached version of all file changes for the given commit.
    file_patch = Column(Text, nullable=False)

    markers = relationship(
        RepositoryFileMarkers,
        backref="repository_file",
        cascade="all, delete-orphan",
        primaryjoin=
        "and_(RepositoryFiles.id==RepositoryFileMarkers.repository_file_id, RepositoryFileMarkers.active==True)",
        single_parent=True,
    )

    comments = relationship(
        RepositoryFileComments,
        backref="repository_file",
        cascade="all, delete-orphan",
        primaryjoin=
        "and_(RepositoryFiles.id==RepositoryFileComments.repository_file_id, RepositoryFileComments.active==True)",
        single_parent=True,
    )
    commit_id = Column(Integer, ForeignKey("vulnerability_git_commits.id"))


class RepositoryFilesSchema(MarshmallowBase):
    # TODO: Add exlude=[] parameter here to skip redundant date and id fields.
    file_patch = ma.Method("get_patch")

    def get_patch(self, obj):
        return "DEPRECATED"

    markers = ma.Nested(RepositoryFileMarkersSchema, many=True)
    comments = ma.Nested(RepositoryFileCommentsSchema, many=True)

    class Meta(MarshmallowBase.Meta):
        model = RepositoryFiles


class VulnerabilityGitCommits(MainBase):
    __tablename__ = "vulnerability_git_commits"

    commit_hash = Column(String(255), nullable=False, index=True)
    _commit_link = Column("commit_link", String(255), nullable=False)
    repo_name = Column(String(255), nullable=False)
    repo_owner = Column(String(255))
    # URL to a *.git Git repository (if applicable).
    _repo_url = Column("repo_url", String(255))
    vulnerability_details_id = Column(Integer, nullable=False)
    version = Column(Integer, default=0, nullable=False)
    ForeignKeyConstraint((vulnerability_details_id, version),
                         ["vulnerability.id", "vulnerability.version"],
                         name="fk_vuln")
    vulnerability = relationship(
        "Vulnerability", foreign_keys=[vulnerability_details_id, version])
    # Used to store/cache the repository tree files with hashes.
    tree_cache = deferred(Column(LONGTEXT()))

    repository_files = relationship(
        RepositoryFiles,
        backref="commit",
        cascade="all, delete-orphan",
        single_parent=True,
    )
    # link to comments through RepositoryFiles
    comments = relationship(
        RepositoryFileComments,
        backref="commit",
        secondary=RepositoryFiles.__table__,
        primaryjoin="VulnerabilityGitCommits.id==RepositoryFiles.commit_id",
        secondaryjoin=
        "and_(RepositoryFiles.id==RepositoryFileComments.repository_file_id, RepositoryFileComments.active==True)",
    )
    # link to markers through RepositoryFiles
    markers = relationship(
        RepositoryFileMarkers,
        backref="commit",
        secondary=RepositoryFiles.__table__,
        primaryjoin="VulnerabilityGitCommits.id==RepositoryFiles.commit_id",
        secondaryjoin=
        "and_(RepositoryFiles.id==RepositoryFileMarkers.repository_file_id, RepositoryFileMarkers.active==True)",
    )

    @property
    def num_files(self):
        # TODO: This should be refactored as it is incredibly inefficient.
        #       We should use a count on the database side instead.
        return len(self.repository_files)

    @property
    def num_comments(self):
        # TODO: see comment regarding performance above.
        return len(self.comments)

    @property
    def num_markers(self):
        # TODO: see comment regarding performance above.
        return len(self.markers)

    @property
    def repo_url(self):
        if not self._repo_url:
            # TODO: Refactor this apporach of retrieving github.com urls.
            if self.commit_link and "github.com" in self.commit_link:
                if self.repo_owner and self.repo_name:
                    return ("https://github.com/" + self.repo_owner + "/" +
                            self.repo_name)
        return self._repo_url

    @repo_url.setter
    def repo_url(self, repo_url):
        self._repo_url = repo_url

    @property
    def commit_link(self):
        return self._commit_link

    @commit_link.setter
    def commit_link(self, commit_link):
        # TODO: Add commit link sanitization back here. We're currently skipping
        #  it as on object creation (populate) there might be no repo_url set
        #  and the commit_link might be just a VCS UI link to the patch.
        #  We should still always require a separate repository link and commit
        #  hash if it's not a simple Github entry.
        # if not self.repo_url and commit_link:
        # vcs_handler = get_vcs_handler(None, commit_link)
        # if not vcs_handler:
        #   raise InvalidIdentifierException('Please provide a valid commit link.')
        if commit_link:
            if not commit_link.startswith("http"):
                raise InvalidIdentifierException(
                    "Please provide a valid commit link.")

        self._commit_link = commit_link

    def __init__(
            self,
            commit_link=None,
            repo_owner=None,
            repo_name=None,
            repo_url=None,
            commit_hash=None,
    ):
        self.repo_owner = repo_owner
        self.repo_name = repo_name
        if repo_url:
            vcs_handler = get_vcs_handler(None, repo_url)
            if not vcs_handler:
                raise InvalidIdentifierException(
                    "Please provide a valid git repo URL.")
            self.repo_url = repo_url
        self.commit_link = commit_link
        self.commit_hash = commit_hash

    def to_json(self):
        """Serialize object properties as dict."""
        return {
            'commit_link': self.commit_link,
            'repo_owner': self.repo_owner,
            'repo_name': self.repo_name,
            'repo_url': self.repo_url,
            'commit_hash': self.commit_hash,
            'relevant_files': self.get_relevant_files()
        }

    def get_relevant_files(self):
        """Extracts the relevant files from tree_cache"""
        relevant_files = []

        if self.tree_cache is None:
            return relevant_files

        tree = json.loads(self.tree_cache)
        if "commit" in tree:
            commit_data = tree["commit"]
            master_commit_files = commit_data["files"]

            for patched_files in master_commit_files:
                relevant_file_path = "./" + patched_files["path"]
                relevant_files.append(relevant_file_path)

        return relevant_files


class Vulnerability(MainBase):
    # __fulltext_columns__ = ('comment',)
    __tablename__ = "vulnerability"
    version = Column(Integer, default=0, nullable=False)
    state = Column(Enum(VulnerabilityState),
                   default=VulnerabilityState.NEW,
                   nullable=False)
    reviewer_id = Column(Integer,
                         ForeignKey(User.id, name='fk_reviewer_id'),
                         nullable=True)
    reviewer = relationship(User, foreign_keys=[reviewer_id])
    review_feedback = Column(Text)
    comment = Column(Text, nullable=False)
    date_created = Column(DateTime,
                          default=func.current_timestamp(),
                          index=True)
    exploit_exists = Column(Boolean, default=False)
    # N.B. Don't use a ForeignKey constraint on NVD here as the nvd data might be
    # updated dynamically (e.g. row deleted and then added by go-cve-dictionary).
    cve_id = Column(String(255), nullable=True, index=True)
    UniqueConstraint('id', version, name='uk_id_ver')
    UniqueConstraint(version, cve_id, name='uk_ver_cve_id')
    creator_id = Column(Integer, ForeignKey(User.id), nullable=True)
    creator = relationship(User, foreign_keys=[creator_id])

    # TODO: Enable this once custom resource links are supported again.
    # resource_links = relationship(
    #     VulnerabilityResources,
    #     backref="vulnerability",
    #     cascade="all, delete-orphan",
    #     single_parent=True,
    # )

    commits = relationship(
        VulnerabilityGitCommits,
        cascade="all, delete-orphan",
        single_parent=True,
        lazy="joined",
    )

    nvd = relationship(
        "Nvd",
        backref="vulns",
        primaryjoin="remote(Nvd.cve_id) == foreign(Vulnerability.cve_id)",
    )

    _has_annotations = None

    def set_has_annotations(self, status=True):
        self._has_annotations = status

    @hybrid_property
    def has_annotations(self):
        if self._has_annotations is not None:
            return self._has_annotations

        if self.commits:
            for c in self.commits:
                if c.comments:
                    self._has_annotations = True
                    return True
        return False

    @has_annotations.expression
    def has_annotations(self):
        return self.commits.any(VulnerabilityGitCommits.comments.any())

    @property
    def master_commit(self):
        # TODO: refactor assumption that the first commit is the "master" one!
        if self.commits:
            return self.commits[0]
        return None

    def __repr__(self):
        return f"Vulnerability Info({vars(self)})"

    @classmethod
    def get_by_id(cls, id):
        return cls.query.filter_by(
            id=id).options(default_vuln_view_options).first()

    @classmethod
    def get_by_cve_id(cls, cve_id):
        return (cls.query.filter_by(
            cve_id=cve_id).options(default_vuln_view_options).first())

    @classmethod
    def get_by_commit_hash(cls, commit_hash):
        return (cls.query.join(
            Vulnerability.commits,
            aliased=True).filter_by(commit_hash=commit_hash).options(
                default_vuln_view_options).first())

    def to_json(self):
        """Prepare object for Json serialisation."""
        products = [{
            'vendor': v,
            'product': p
        } for v, p in self.nvd.get_products()]
        cwes = [{'id': c.cwe_id, 'name': c.cwe_name} for c in self.nvd.cwes]
        return {
            'comment': self.comment,
            'cve_id': self.cve_id,
            'cwes': cwes,
            'description': self.nvd.description,
            'exploit_exists': self.exploit_exists,
            'has_annotations': self.has_annotations,
            'is_processed': True,
            'langs': self.nvd.get_languages(),
            'master_commit': self.master_commit.to_json(),
            'products': products,
            'references': [l.link for l in self.nvd.references],
            'score': self.nvd.score,
        }

    def to_json_full(self):
        """Serialize object properties as dict."""
        data = self.to_json()
        # TODO: Enable this once custom resource_links are supported again.
        #data['resource_links'] = [
        #    r.to_json() for r in self.resource_links
        #    if self.resource_links is not None
        #]
        data['commits'] = [
            c.to_json() for c in self.commits if self.commits is not None
        ]
        data['nvd'] = self.nvd._to_json_full(
        ) if self.nvd is not None else None
        data['creator'] = self.creator.to_json(
        ) if self.creator is not None else None
        data['date_created'] = self.date_created
        data['date_modified'] = self.date_modified

        return data


class OpenSourceProducts(MainBase):
    __tablename__ = "oss_products"
    vendor = Column(String(255), nullable=False)
    product = Column(String(255), nullable=False)

    def to_json(self):
        """Serialize object properties as dict."""
        return {'vendor': self.vendor, 'product': self.product}


Index("idx_oss_products_main",
      OpenSourceProducts.vendor,
      OpenSourceProducts.product,
      unique=True)

# TODO: Refactor these filters. We might want to use them as lazy loads instead.
# Currently, querying like this eats up quite some time.
# See for example: /CVE-2014-0160
load_relationships1 = joinedload(Vulnerability.commits).joinedload(
    VulnerabilityGitCommits.repository_files).joinedload(
        RepositoryFiles.comments)

load_relationships2 = joinedload(Vulnerability.commits).joinedload(
    VulnerabilityGitCommits.repository_files).joinedload(
        RepositoryFiles.markers)

load_relationships3 = joinedload(Vulnerability.commits).joinedload(
    VulnerabilityGitCommits.comments).joinedload(
        RepositoryFileComments.repository_file)

default_vuln_view_options = [
    load_relationships1,
    load_relationships2,
    load_relationships3,
]

# must be set after all definitions
__all__ = populate_models(__name__)
